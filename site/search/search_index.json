{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs","title":"Home"},{"location":"#welcome-to-mkdocs","text":"","title":"Welcome to MkDocs"},{"location":"readme/","text":"Host Documentation on GitHub using MkDocs python --version mkdocks --version pip install mkdocs mkdocs new . pip install mkdocs-material mkdocs serve mkdocs gh-deploy hello","title":"setup"},{"location":"az-204/az-204/","text":"\ud83d\udd11 1. Azure Compute Solutions App Service Purpose : Platform-as-a-Service (PaaS) offering for hosting web applications, REST APIs, and mobile backends Features : Automatic scaling Built-in load balancing Support for .NET, .NET Core, Java, Ruby, Node.js, PHP, Python Continuous deployment from GitHub, Azure DevOps, or any Git repo Use Cases : Web applications, API backends, mobile app backends Advantages : No infrastructure management, supports custom domains and SSL Functions Purpose : Serverless compute service for running event-triggered code Key Characteristics : Pay-per-execution pricing model Automatic scaling Supports multiple languages (C#, Java, JavaScript, Python, PowerShell) Trigger Types : HTTP (API endpoints) Timer (scheduled tasks) Blob Storage (file uploads) Queue Storage (message processing) Event Grid (event processing) Use Cases : Microservices, event processing, lightweight APIs ACI (Azure Container Instances) & AKS (Azure Kubernetes Service) ACI : Simplest way to run containers in Azure No orchestration needed Fast startup (seconds) Ideal for: One-off tasks, dev/test scenarios, simple applications AKS : Managed Kubernetes service Full container orchestration Features: Auto-scaling, self-healing, load balancing Ideal for: Microservices architectures, production workloads Virtual Machines Purpose : Infrastructure-as-a-Service (IaaS) offering for full control over OS and environment Characteristics : Complete control over the virtualized hardware Supports Windows and Linux Various sizes optimized for different workloads Use Cases : Legacy applications requiring specific OS versions Custom software stacks High-performance computing Applications requiring direct access to hardware \ufffd 2. Azure Storage Solutions Blob Storage Purpose : Object storage for massive amounts of unstructured data Access Tiers : Hot: Frequently accessed data Cool: Infrequently accessed data (lower cost) Archive: Rarely accessed data (lowest cost, retrieval latency) Features : Tier lifecycle management Data encryption at rest Shared Access Signatures (SAS) for secure access Table Storage Purpose : NoSQL key-value store for semi-structured data Characteristics : Schemaless design Fast, cost-effective for large volumes of simple data Partition key + row key structure Use Cases : User data, device information, metadata storage Queue Storage Purpose : Message queue service for asynchronous communication Features : First-In-First-Out (FIFO) processing At-least-once delivery Message time-to-live (TTL) configuration Use Cases : Decoupling application components, load leveling File Storage Purpose : Fully managed file shares using SMB protocol Characteristics : Accessible from cloud or on-premises Supports concurrent access Can be cached on Windows Servers with Azure File Sync Use Cases : Lift-and-shift of file-based applications, shared configuration files \ud83d\udd11 3.Azure Security Azure AD (Active Directory) Purpose : Cloud-based identity and access management service Features : Single sign-on (SSO) Multi-factor authentication (MFA) Application management Device management B2B and B2C capabilities OAuth 2.0/OpenID Connect OAuth 2.0 : Authorization framework for delegated access OpenID Connect : Authentication layer built on OAuth 2.0 Flow Types : Authorization Code (web apps) Implicit (SPAs) Client Credentials (service-to-service) Device Code (IoT/CLI) Managed Identity Purpose : Automatically managed identity in Azure AD for Azure services Types : System-assigned (tied to resource lifecycle) User-assigned (standalone identity) Benefits : Eliminates need for credentials in code Key Vault Purpose : Centralized secrets management Stores : Secrets (passwords, connection strings) Keys (encryption keys) Certificates Features : Access policies and RBAC Hardware security modules (HSMs) Versioning RBAC (Role-Based Access Control) Purpose : Granular access management for Azure resources Components : Security principal (who) Role definition (what permissions) Scope (where) Built-in Roles : Owner, Contributor, Reader Service-specific roles \ud83d\udd11 4. Monitoring, Troubleshooting, and Optimization Application Insights Purpose : Application performance management (APM) service Monitors : Request rates, response times, failure rates Dependency tracking Exceptions and logs Custom metrics and events Azure Monitor Purpose : Comprehensive solution for collecting, analyzing, and acting on telemetry Components : Metrics: Numerical values from resources Logs: Log data with KQL queries Alerts: Notifications based on conditions Workbooks: Interactive reports Log Analytics Purpose : Log data repository and query engine Features : Kusto Query Language (KQL) for powerful analytics Cross-resource queries Saved queries and functions Integration with Azure Monitor Alerts/Autoscale Alerts : Metric alerts (threshold-based) Log alerts (query-based) Activity log alerts (operations-based) Autoscale : Scale based on metrics or schedules Scale sets for VMs App Service scale-out \ud83d\udd11 5. Data Solutions Cosmos DB Purpose : Globally distributed, multi-model database service Consistency Levels : Strong, Bounded Staleness, Session, Consistent Prefix, Eventual APIs Supported : SQL, MongoDB, Cassandra, Gremlin, Table Features : Turnkey global distribution SLA-backed latency and availability Automatic indexing SQL Database Purpose : Fully managed relational database Deployment Models : Single database Elastic pool (shared resources) Managed instance (near-complete SQL Server compatibility) Features : Built-in high availability Intelligent performance tuning Advanced threat protection EF Core (Entity Framework Core) Purpose : Object-Relational Mapper (ORM) for .NET Features : LINQ support Change tracking Database migrations Cross-platform Use with Azure : Simplifies data access to Azure SQL, Cosmos DB \ud83d\udd11 6. Integrating Azure Services Event Grid Purpose : Event routing service using publish-subscribe model Characteristics : Fully managed event routing Supports custom and Azure service events Push-based delivery Use Cases : Reacting to blob storage events, custom event processing Event Hubs Purpose : Big data streaming platform and event ingestion service Features : High throughput (millions of events/sec) Capture feature for automatic data persistence Kafka compatibility Use Cases : IoT telemetry, clickstream analytics Service Bus Purpose : Enterprise messaging with queues and publish-subscribe topics Features : FIFO guarantees Dead-letter queues Duplicate detection Sessions for message ordering Use Cases : Order processing, financial transactions Logic Apps Purpose : Serverless workflow automation Characteristics : Visual designer 200+ connectors Enterprise Integration Pack for B2B scenarios Use Cases : Business process automation, system integration API Management (APIM) Purpose : API gateway for publishing, securing, and analyzing APIs Features : Rate limiting Request/response transformation Developer portal Multiple authentication options \ud83d\udd11 7. Deploying and Managing Resources ARM Templates Purpose : Infrastructure as Code (IaC) for Azure Characteristics : JSON format Declarative syntax Idempotent deployments Modular design with linked templates Azure CLI/PowerShell Azure CLI : Cross-platform command-line tool Bash-like syntax Interactive mode available Azure PowerShell : PowerShell cmdlets for Azure More granular control than CLI Ideal for Windows environments Resource Manager (ARM) Purpose : Deployment and management service for Azure Features : Group resources into resource groups Dependency handling Tagging for organization Access control CI/CD with GitHub Actions/Azure DevOps GitHub Actions : YAML-based workflows Tight GitHub integration Marketplace for actions Azure DevOps : Pipelines for CI/CD Test plans Artifact feeds Full application lifecycle management \ud83d\udd11 8. Caching and Performance Optimization Azure Redis Cache Purpose : In-memory data store based on Redis Tiers : Basic (single node) Standard (replicated) Premium (with persistence and clustering) Use Cases : Session store, output cache, message broker CDN (Content Delivery Network) Purpose : Global content caching for improved performance Features : Edge locations worldwide Custom domains and HTTPS Rules engine for content handling Integration with Storage and Web Apps \ud83d\udd11 9. API and Web App Development Secure API Development Authentication : Azure AD integration OAuth 2.0 flows API keys (for simpler scenarios) Best Practices : Proper status codes Versioning Throttling Input validation Swagger/OpenAPI Purpose : API description format Features : Machine-readable API contracts Interactive documentation Client SDK generation Integration with API Management \ud83d\udd11 10. Messaging Patterns Queue-based Load Leveling Pattern : Use a queue as buffer between components Benefits : Smooths intermittent heavy loads Prevents resource exhaustion Enables asynchronous processing Competing Consumers Pattern : Multiple consumers process messages from same queue Benefits : Increased throughput Horizontal scaling Fault tolerance Publisher/Subscriber Pattern : Events distributed to multiple subscribers Azure Services : Event Grid (lightweight) Service Bus Topics (enterprise) Event Hubs (high volume)","title":"AZ-204"},{"location":"az-204/az-204/#1-azure-compute-solutions","text":"","title":"\ud83d\udd11 1. Azure Compute Solutions"},{"location":"az-204/az-204/#app-service","text":"Purpose : Platform-as-a-Service (PaaS) offering for hosting web applications, REST APIs, and mobile backends Features : Automatic scaling Built-in load balancing Support for .NET, .NET Core, Java, Ruby, Node.js, PHP, Python Continuous deployment from GitHub, Azure DevOps, or any Git repo Use Cases : Web applications, API backends, mobile app backends Advantages : No infrastructure management, supports custom domains and SSL","title":"App Service"},{"location":"az-204/az-204/#functions","text":"Purpose : Serverless compute service for running event-triggered code Key Characteristics : Pay-per-execution pricing model Automatic scaling Supports multiple languages (C#, Java, JavaScript, Python, PowerShell) Trigger Types : HTTP (API endpoints) Timer (scheduled tasks) Blob Storage (file uploads) Queue Storage (message processing) Event Grid (event processing) Use Cases : Microservices, event processing, lightweight APIs","title":"Functions"},{"location":"az-204/az-204/#aci-azure-container-instances-aks-azure-kubernetes-service","text":"ACI : Simplest way to run containers in Azure No orchestration needed Fast startup (seconds) Ideal for: One-off tasks, dev/test scenarios, simple applications AKS : Managed Kubernetes service Full container orchestration Features: Auto-scaling, self-healing, load balancing Ideal for: Microservices architectures, production workloads","title":"ACI (Azure Container Instances) &amp; AKS (Azure Kubernetes Service)"},{"location":"az-204/az-204/#virtual-machines","text":"Purpose : Infrastructure-as-a-Service (IaaS) offering for full control over OS and environment Characteristics : Complete control over the virtualized hardware Supports Windows and Linux Various sizes optimized for different workloads Use Cases : Legacy applications requiring specific OS versions Custom software stacks High-performance computing Applications requiring direct access to hardware","title":"Virtual Machines"},{"location":"az-204/az-204/#2-azure-storage-solutions","text":"","title":"\ufffd 2. Azure Storage Solutions"},{"location":"az-204/az-204/#blob-storage","text":"Purpose : Object storage for massive amounts of unstructured data Access Tiers : Hot: Frequently accessed data Cool: Infrequently accessed data (lower cost) Archive: Rarely accessed data (lowest cost, retrieval latency) Features : Tier lifecycle management Data encryption at rest Shared Access Signatures (SAS) for secure access","title":"Blob Storage"},{"location":"az-204/az-204/#table-storage","text":"Purpose : NoSQL key-value store for semi-structured data Characteristics : Schemaless design Fast, cost-effective for large volumes of simple data Partition key + row key structure Use Cases : User data, device information, metadata storage","title":"Table Storage"},{"location":"az-204/az-204/#queue-storage","text":"Purpose : Message queue service for asynchronous communication Features : First-In-First-Out (FIFO) processing At-least-once delivery Message time-to-live (TTL) configuration Use Cases : Decoupling application components, load leveling","title":"Queue Storage"},{"location":"az-204/az-204/#file-storage","text":"Purpose : Fully managed file shares using SMB protocol Characteristics : Accessible from cloud or on-premises Supports concurrent access Can be cached on Windows Servers with Azure File Sync Use Cases : Lift-and-shift of file-based applications, shared configuration files","title":"File Storage"},{"location":"az-204/az-204/#3azure-security","text":"","title":"\ud83d\udd11 3.Azure Security"},{"location":"az-204/az-204/#azure-ad-active-directory","text":"Purpose : Cloud-based identity and access management service Features : Single sign-on (SSO) Multi-factor authentication (MFA) Application management Device management B2B and B2C capabilities","title":"Azure AD (Active Directory)"},{"location":"az-204/az-204/#oauth-20openid-connect","text":"OAuth 2.0 : Authorization framework for delegated access OpenID Connect : Authentication layer built on OAuth 2.0 Flow Types : Authorization Code (web apps) Implicit (SPAs) Client Credentials (service-to-service) Device Code (IoT/CLI)","title":"OAuth 2.0/OpenID Connect"},{"location":"az-204/az-204/#managed-identity","text":"Purpose : Automatically managed identity in Azure AD for Azure services Types : System-assigned (tied to resource lifecycle) User-assigned (standalone identity) Benefits : Eliminates need for credentials in code","title":"Managed Identity"},{"location":"az-204/az-204/#key-vault","text":"Purpose : Centralized secrets management Stores : Secrets (passwords, connection strings) Keys (encryption keys) Certificates Features : Access policies and RBAC Hardware security modules (HSMs) Versioning","title":"Key Vault"},{"location":"az-204/az-204/#rbac-role-based-access-control","text":"Purpose : Granular access management for Azure resources Components : Security principal (who) Role definition (what permissions) Scope (where) Built-in Roles : Owner, Contributor, Reader Service-specific roles","title":"RBAC (Role-Based Access Control)"},{"location":"az-204/az-204/#4-monitoring-troubleshooting-and-optimization","text":"","title":"\ud83d\udd11 4. Monitoring, Troubleshooting, and Optimization"},{"location":"az-204/az-204/#application-insights","text":"Purpose : Application performance management (APM) service Monitors : Request rates, response times, failure rates Dependency tracking Exceptions and logs Custom metrics and events","title":"Application Insights"},{"location":"az-204/az-204/#azure-monitor","text":"Purpose : Comprehensive solution for collecting, analyzing, and acting on telemetry Components : Metrics: Numerical values from resources Logs: Log data with KQL queries Alerts: Notifications based on conditions Workbooks: Interactive reports","title":"Azure Monitor"},{"location":"az-204/az-204/#log-analytics","text":"Purpose : Log data repository and query engine Features : Kusto Query Language (KQL) for powerful analytics Cross-resource queries Saved queries and functions Integration with Azure Monitor","title":"Log Analytics"},{"location":"az-204/az-204/#alertsautoscale","text":"Alerts : Metric alerts (threshold-based) Log alerts (query-based) Activity log alerts (operations-based) Autoscale : Scale based on metrics or schedules Scale sets for VMs App Service scale-out","title":"Alerts/Autoscale"},{"location":"az-204/az-204/#5-data-solutions","text":"","title":"\ud83d\udd11 5. Data Solutions"},{"location":"az-204/az-204/#cosmos-db","text":"Purpose : Globally distributed, multi-model database service Consistency Levels : Strong, Bounded Staleness, Session, Consistent Prefix, Eventual APIs Supported : SQL, MongoDB, Cassandra, Gremlin, Table Features : Turnkey global distribution SLA-backed latency and availability Automatic indexing","title":"Cosmos DB"},{"location":"az-204/az-204/#sql-database","text":"Purpose : Fully managed relational database Deployment Models : Single database Elastic pool (shared resources) Managed instance (near-complete SQL Server compatibility) Features : Built-in high availability Intelligent performance tuning Advanced threat protection","title":"SQL Database"},{"location":"az-204/az-204/#ef-core-entity-framework-core","text":"Purpose : Object-Relational Mapper (ORM) for .NET Features : LINQ support Change tracking Database migrations Cross-platform Use with Azure : Simplifies data access to Azure SQL, Cosmos DB","title":"EF Core (Entity Framework Core)"},{"location":"az-204/az-204/#6-integrating-azure-services","text":"","title":"\ud83d\udd11 6. Integrating Azure Services"},{"location":"az-204/az-204/#event-grid","text":"Purpose : Event routing service using publish-subscribe model Characteristics : Fully managed event routing Supports custom and Azure service events Push-based delivery Use Cases : Reacting to blob storage events, custom event processing","title":"Event Grid"},{"location":"az-204/az-204/#event-hubs","text":"Purpose : Big data streaming platform and event ingestion service Features : High throughput (millions of events/sec) Capture feature for automatic data persistence Kafka compatibility Use Cases : IoT telemetry, clickstream analytics","title":"Event Hubs"},{"location":"az-204/az-204/#service-bus","text":"Purpose : Enterprise messaging with queues and publish-subscribe topics Features : FIFO guarantees Dead-letter queues Duplicate detection Sessions for message ordering Use Cases : Order processing, financial transactions","title":"Service Bus"},{"location":"az-204/az-204/#logic-apps","text":"Purpose : Serverless workflow automation Characteristics : Visual designer 200+ connectors Enterprise Integration Pack for B2B scenarios Use Cases : Business process automation, system integration","title":"Logic Apps"},{"location":"az-204/az-204/#api-management-apim","text":"Purpose : API gateway for publishing, securing, and analyzing APIs Features : Rate limiting Request/response transformation Developer portal Multiple authentication options","title":"API Management (APIM)"},{"location":"az-204/az-204/#7-deploying-and-managing-resources","text":"","title":"\ud83d\udd11 7. Deploying and Managing Resources"},{"location":"az-204/az-204/#arm-templates","text":"Purpose : Infrastructure as Code (IaC) for Azure Characteristics : JSON format Declarative syntax Idempotent deployments Modular design with linked templates","title":"ARM Templates"},{"location":"az-204/az-204/#azure-clipowershell","text":"Azure CLI : Cross-platform command-line tool Bash-like syntax Interactive mode available Azure PowerShell : PowerShell cmdlets for Azure More granular control than CLI Ideal for Windows environments","title":"Azure CLI/PowerShell"},{"location":"az-204/az-204/#resource-manager-arm","text":"Purpose : Deployment and management service for Azure Features : Group resources into resource groups Dependency handling Tagging for organization Access control","title":"Resource Manager (ARM)"},{"location":"az-204/az-204/#cicd-with-github-actionsazure-devops","text":"GitHub Actions : YAML-based workflows Tight GitHub integration Marketplace for actions Azure DevOps : Pipelines for CI/CD Test plans Artifact feeds Full application lifecycle management","title":"CI/CD with GitHub Actions/Azure DevOps"},{"location":"az-204/az-204/#8-caching-and-performance-optimization","text":"","title":"\ud83d\udd11 8. Caching and Performance Optimization"},{"location":"az-204/az-204/#azure-redis-cache","text":"Purpose : In-memory data store based on Redis Tiers : Basic (single node) Standard (replicated) Premium (with persistence and clustering) Use Cases : Session store, output cache, message broker CDN (Content Delivery Network) Purpose : Global content caching for improved performance Features : Edge locations worldwide Custom domains and HTTPS Rules engine for content handling Integration with Storage and Web Apps","title":"Azure Redis Cache"},{"location":"az-204/az-204/#9-api-and-web-app-development","text":"","title":"\ud83d\udd11 9. API and Web App Development"},{"location":"az-204/az-204/#secure-api-development","text":"Authentication : Azure AD integration OAuth 2.0 flows API keys (for simpler scenarios) Best Practices : Proper status codes Versioning Throttling Input validation","title":"Secure API Development"},{"location":"az-204/az-204/#swaggeropenapi","text":"Purpose : API description format Features : Machine-readable API contracts Interactive documentation Client SDK generation Integration with API Management","title":"Swagger/OpenAPI"},{"location":"az-204/az-204/#10-messaging-patterns","text":"","title":"\ud83d\udd11 10. Messaging Patterns"},{"location":"az-204/az-204/#queue-based-load-leveling","text":"Pattern : Use a queue as buffer between components Benefits : Smooths intermittent heavy loads Prevents resource exhaustion Enables asynchronous processing","title":"Queue-based Load Leveling"},{"location":"az-204/az-204/#competing-consumers","text":"Pattern : Multiple consumers process messages from same queue Benefits : Increased throughput Horizontal scaling Fault tolerance","title":"Competing Consumers"},{"location":"az-204/az-204/#publishersubscriber","text":"Pattern : Events distributed to multiple subscribers Azure Services : Event Grid (lightweight) Service Bus Topics (enterprise) Event Hubs (high volume)","title":"Publisher/Subscriber"},{"location":"docker/docker/","text":"1. Introduction to Docker and Containerization Docker is an open-source platform that enables developers to package applications and their dependencies into standardized units called containers. Containerization is a lightweight alternative to full machine virtualization that: Packages software in isolated environments Shares the host OS kernel Runs consistently across different infrastructures Key concepts: Images: Read-only templates for creating containers Containers: Runnable instances of images Docker Engine: The runtime that manages containers 2. Benefits of Using Docker Benefit Description Portability Runs identically on any system with Docker installed Efficiency Containers share the OS kernel, using fewer resources than VMs Isolation Applications run in separate, secure environments Scalability Easy to scale services horizontally Consistency Eliminates \"works on my machine\" problems Fast Deployment Containers start in seconds 3. Docker vs Virtual Machines Feature Docker Containers Virtual Machines OS Shares host OS Requires full guest OS Startup Time Seconds Minutes Performance Near-native Slight overhead Disk Usage MBs (layered images) GBs (full OS) Isolation Process-level Hardware-level Use Case Microservices, CI/CD Legacy apps, full OS needs 4. Docker Architecture Docker System Components Docker Client : CLI interface ( docker command) to interact with the Docker daemon. Docker Host : Runs the Docker daemon and manages containers. Registry : Central repository to store and distribute Docker images (e.g., Docker Hub, private registries). 5. Key Docker Components Docker Core Components Component Description Docker Engine Core runtime ( dockerd ) Images Immutable templates (e.g., nginx:latest ) Containers Runnable instances of images Volumes Persistent data storage Networks Isolated communication channels Dockerfile Blueprint for building images Docker Hub Public image repository 6. Docker CLI Commands \ud83d\udc33 Image Management docker pull nginx # Download image docker images # List images docker rmi nginx # Remove image docker build -t myapp . # Build from Dockerfile Container Management docker run -d -p 80:80 nginx # Run container docker ps # List running containers docker stop <container_id> # Stop container docker rm <container_id> # Remove container docker exec -it nginx bash # Enter running container Volume Management docker volume create myvol # Create volume docker volume ls # List volumes docker volume inspect myvol # View volume details Network Management docker network create mynet # Create network docker network ls # List networks docker network inspect mynet # View network details 7. Dockerfile Syntax and Example Common Instructions Instruction Purpose FROM Base image WORKDIR Working directory COPY Add files RUN Execute commands EXPOSE Document ports CMD Default command Example Dockerfile # Multi-stage build for Java app FROM maven:3.8-jdk-11 AS build WORKDIR /app COPY pom.xml . RUN mvn dependency:go-offline COPY src/ ./src/ RUN mvn package FROM openjdk:11-jre WORKDIR /app COPY --from=build /app/target/myapp.jar . EXPOSE 8080 CMD [\"java\", \"-jar\", \"myapp.jar\"] 8. Kubernetes Deployment Definition Kubernetes is a container orchestration system that automates deployment, scaling, and management of containerized applications. Full-Stack Example Backend Dockerfile (Spring Boot): FROM maven:3.8-jdk-11 AS build WORKDIR /app COPY pom.xml . RUN mvn dependency:go-offline COPY src/ ./src/ RUN mvn package -DskipTests FROM openjdk:11-jre WORKDIR /app COPY --from=build /app/target/backend.jar . EXPOSE 8080 CMD [\"java\", \"-jar\", \"backend.jar\"] Frontend Dockerfile (Angular): FROM node:16 AS build WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build FROM nginx:alpine COPY --from=build /app/dist/frontend /usr/share/nginx/html EXPOSE 80 Kubernetes Deployment (k8s-deployment.yml): apiVersion: apps/v1 kind: Deployment metadata: name: backend spec: replicas: 2 selector: matchLabels: app: backend template: metadata: labels: app: backend spec: containers: - name: backend image: myrepo/backend:latest ports: - containerPort: 8080 env: - name: DB_HOST value: \"mysql-service\" --- apiVersion: v1 kind: Service metadata: name: backend-service spec: selector: app: backend ports: - protocol: TCP port: 80 targetPort: 8080 type: LoadBalancer --- apiVersion: apps/v1 kind: Deployment metadata: name: frontend spec: replicas: 2 selector: matchLabels: app: frontend template: metadata: labels: app: frontend spec: containers: - name: frontend image: myrepo/frontend:latest ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: frontend-service spec: selector: app: frontend ports: - protocol: TCP port: 80 targetPort: 80 type: LoadBalancer --- apiVersion: apps/v1 kind: Deployment metadata: name: mysql spec: selector: matchLabels: app: mysql template: metadata: labels: app: mysql spec: containers: - name: mysql image: mysql:5.7 env: - name: MYSQL_ROOT_PASSWORD value: \"password\" ports: - containerPort: 3306 volumeMounts: - name: mysql-persistent-storage mountPath: /var/lib/mysql volumes: - name: mysql-persistent-storage persistentVolumeClaim: claimName: mysql-pv-claim --- apiVersion: v1 kind: PersistentVolumeClaim metadata: name: mysql-pv-claim spec: accessModes: - ReadWriteOnce resources: requests: storage: 5Gi Service Interaction Frontend (Angular) makes API calls to backend-service Backend (Spring Boot) connects to mysql-service Kubernetes DNS resolves service names automatically 9. Docker Networking Types Network Type Description Use Case Bridge Default network (NAT) Single-host communication Host Shares host's network High-performance needs Overlay Multi-host network Swarm/Kubernetes clusters Macvlan Assigns MAC addresses Legacy apps needing MAC access 10. Docker Volumes Volume Type Description Use Case Named Managed by Docker Persistent data Anonymous Auto-removed Temporary data Bind Mount Host directory Development mounts tmpfs Memory-only Sensitive temp data ------------------ ------------------------ -------------------------- 11. Docker Logs and Inspection docker logs <container> # View logs docker logs -f <container> # Follow logs in real-time docker exec -it <container> bash # Enter container's shell docker inspect <container> # Detailed container info docker stats # Show live resource usage 12. Docker Security Best Practices Use official images from trusted sources Run containers as non-root user: USER appuser Scan images for vulnerabilities Limit container capabilities: docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE Use secrets for sensitive data Keep Docker Engine and images updated 13. Docker in CI/CD Typical CI/CD Pipeline: Code commit triggers build Docker image is built and tested Image pushed to registry Kubernetes deploys new version Automated rollback if tests fail GitHub Actions snippet: - name: Build and push uses: docker/build-push-action@v2 with: push: true tags: user/app:latest 14. Dockerfile Best Practices Use .dockerignore to exclude unnecessary files Order instructions from least to most frequently changed Use multi-stage builds to reduce image size Pin versions for base images and dependencies Minimize layers by combining RUN commands Use smallest suitable base image (e.g., Alpine Linux) 15. Cleanup Commands docker system prune # Remove unused objects docker system prune -a # Remove all unused images docker volume prune # Remove unused volumes docker network prune # Remove unused networks docker rm $(docker ps -aq) # Remove all stopped containers 16. Conclusion: Why Docker is Essential Docker has become fundamental to modern DevOps because it: Standardizes application packaging and deployment Enables microservices architecture Facilitates CI/CD pipelines Improves development/production parity Optimizes resource utilization Simplifies scaling and orchestration (with Kubernetes) When combined with Kubernetes, Docker provides a complete solution for building, shipping, and running distributed applications at scale.","title":"docker"},{"location":"docker/docker/#1-introduction-to-docker-and-containerization","text":"Docker is an open-source platform that enables developers to package applications and their dependencies into standardized units called containers. Containerization is a lightweight alternative to full machine virtualization that: Packages software in isolated environments Shares the host OS kernel Runs consistently across different infrastructures Key concepts: Images: Read-only templates for creating containers Containers: Runnable instances of images Docker Engine: The runtime that manages containers","title":"1. Introduction to Docker and Containerization"},{"location":"docker/docker/#2-benefits-of-using-docker","text":"Benefit Description Portability Runs identically on any system with Docker installed Efficiency Containers share the OS kernel, using fewer resources than VMs Isolation Applications run in separate, secure environments Scalability Easy to scale services horizontally Consistency Eliminates \"works on my machine\" problems Fast Deployment Containers start in seconds","title":"2. Benefits of Using Docker"},{"location":"docker/docker/#3-docker-vs-virtual-machines","text":"Feature Docker Containers Virtual Machines OS Shares host OS Requires full guest OS Startup Time Seconds Minutes Performance Near-native Slight overhead Disk Usage MBs (layered images) GBs (full OS) Isolation Process-level Hardware-level Use Case Microservices, CI/CD Legacy apps, full OS needs","title":"3. Docker vs Virtual Machines"},{"location":"docker/docker/#4-docker-architecture","text":"","title":"4. Docker Architecture"},{"location":"docker/docker/#docker-system-components","text":"Docker Client : CLI interface ( docker command) to interact with the Docker daemon. Docker Host : Runs the Docker daemon and manages containers. Registry : Central repository to store and distribute Docker images (e.g., Docker Hub, private registries).","title":"Docker System Components"},{"location":"docker/docker/#5-key-docker-components","text":"","title":"5. Key Docker Components"},{"location":"docker/docker/#docker-core-components","text":"Component Description Docker Engine Core runtime ( dockerd ) Images Immutable templates (e.g., nginx:latest ) Containers Runnable instances of images Volumes Persistent data storage Networks Isolated communication channels Dockerfile Blueprint for building images Docker Hub Public image repository","title":"Docker Core Components"},{"location":"docker/docker/#6-docker-cli-commands","text":"","title":"6. Docker CLI Commands"},{"location":"docker/docker/#image-management","text":"docker pull nginx # Download image docker images # List images docker rmi nginx # Remove image docker build -t myapp . # Build from Dockerfile","title":"\ud83d\udc33 Image Management"},{"location":"docker/docker/#container-management","text":"docker run -d -p 80:80 nginx # Run container docker ps # List running containers docker stop <container_id> # Stop container docker rm <container_id> # Remove container docker exec -it nginx bash # Enter running container","title":"Container Management"},{"location":"docker/docker/#volume-management","text":"docker volume create myvol # Create volume docker volume ls # List volumes docker volume inspect myvol # View volume details","title":"Volume Management"},{"location":"docker/docker/#network-management","text":"docker network create mynet # Create network docker network ls # List networks docker network inspect mynet # View network details","title":"Network Management"},{"location":"docker/docker/#7-dockerfile-syntax-and-example","text":"","title":"7. Dockerfile Syntax and Example"},{"location":"docker/docker/#common-instructions","text":"Instruction Purpose FROM Base image WORKDIR Working directory COPY Add files RUN Execute commands EXPOSE Document ports CMD Default command","title":"Common Instructions"},{"location":"docker/docker/#example-dockerfile","text":"# Multi-stage build for Java app FROM maven:3.8-jdk-11 AS build WORKDIR /app COPY pom.xml . RUN mvn dependency:go-offline COPY src/ ./src/ RUN mvn package FROM openjdk:11-jre WORKDIR /app COPY --from=build /app/target/myapp.jar . EXPOSE 8080 CMD [\"java\", \"-jar\", \"myapp.jar\"]","title":"Example Dockerfile"},{"location":"docker/docker/#8-kubernetes-deployment","text":"","title":"8. Kubernetes Deployment"},{"location":"docker/docker/#definition","text":"Kubernetes is a container orchestration system that automates deployment, scaling, and management of containerized applications.","title":"Definition"},{"location":"docker/docker/#full-stack-example","text":"Backend Dockerfile (Spring Boot): FROM maven:3.8-jdk-11 AS build WORKDIR /app COPY pom.xml . RUN mvn dependency:go-offline COPY src/ ./src/ RUN mvn package -DskipTests FROM openjdk:11-jre WORKDIR /app COPY --from=build /app/target/backend.jar . EXPOSE 8080 CMD [\"java\", \"-jar\", \"backend.jar\"] Frontend Dockerfile (Angular): FROM node:16 AS build WORKDIR /app COPY package*.json ./ RUN npm install COPY . . RUN npm run build FROM nginx:alpine COPY --from=build /app/dist/frontend /usr/share/nginx/html EXPOSE 80 Kubernetes Deployment (k8s-deployment.yml): apiVersion: apps/v1 kind: Deployment metadata: name: backend spec: replicas: 2 selector: matchLabels: app: backend template: metadata: labels: app: backend spec: containers: - name: backend image: myrepo/backend:latest ports: - containerPort: 8080 env: - name: DB_HOST value: \"mysql-service\" --- apiVersion: v1 kind: Service metadata: name: backend-service spec: selector: app: backend ports: - protocol: TCP port: 80 targetPort: 8080 type: LoadBalancer --- apiVersion: apps/v1 kind: Deployment metadata: name: frontend spec: replicas: 2 selector: matchLabels: app: frontend template: metadata: labels: app: frontend spec: containers: - name: frontend image: myrepo/frontend:latest ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: frontend-service spec: selector: app: frontend ports: - protocol: TCP port: 80 targetPort: 80 type: LoadBalancer --- apiVersion: apps/v1 kind: Deployment metadata: name: mysql spec: selector: matchLabels: app: mysql template: metadata: labels: app: mysql spec: containers: - name: mysql image: mysql:5.7 env: - name: MYSQL_ROOT_PASSWORD value: \"password\" ports: - containerPort: 3306 volumeMounts: - name: mysql-persistent-storage mountPath: /var/lib/mysql volumes: - name: mysql-persistent-storage persistentVolumeClaim: claimName: mysql-pv-claim --- apiVersion: v1 kind: PersistentVolumeClaim metadata: name: mysql-pv-claim spec: accessModes: - ReadWriteOnce resources: requests: storage: 5Gi","title":"Full-Stack Example"},{"location":"docker/docker/#service-interaction","text":"Frontend (Angular) makes API calls to backend-service Backend (Spring Boot) connects to mysql-service Kubernetes DNS resolves service names automatically","title":"Service Interaction"},{"location":"docker/docker/#9-docker-networking-types","text":"Network Type Description Use Case Bridge Default network (NAT) Single-host communication Host Shares host's network High-performance needs Overlay Multi-host network Swarm/Kubernetes clusters Macvlan Assigns MAC addresses Legacy apps needing MAC access","title":"9. Docker Networking Types"},{"location":"docker/docker/#10-docker-volumes","text":"Volume Type Description Use Case Named Managed by Docker Persistent data Anonymous Auto-removed Temporary data Bind Mount Host directory Development mounts tmpfs Memory-only Sensitive temp data ------------------ ------------------------ --------------------------","title":"10. Docker Volumes"},{"location":"docker/docker/#11-docker-logs-and-inspection","text":"docker logs <container> # View logs docker logs -f <container> # Follow logs in real-time docker exec -it <container> bash # Enter container's shell docker inspect <container> # Detailed container info docker stats # Show live resource usage","title":"11. Docker Logs and Inspection"},{"location":"docker/docker/#12-docker-security-best-practices","text":"Use official images from trusted sources Run containers as non-root user: USER appuser Scan images for vulnerabilities Limit container capabilities: docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE Use secrets for sensitive data Keep Docker Engine and images updated","title":"12. Docker Security Best Practices"},{"location":"docker/docker/#13-docker-in-cicd","text":"Typical CI/CD Pipeline: Code commit triggers build Docker image is built and tested Image pushed to registry Kubernetes deploys new version Automated rollback if tests fail GitHub Actions snippet: - name: Build and push uses: docker/build-push-action@v2 with: push: true tags: user/app:latest","title":"13. Docker in CI/CD"},{"location":"docker/docker/#14-dockerfile-best-practices","text":"Use .dockerignore to exclude unnecessary files Order instructions from least to most frequently changed Use multi-stage builds to reduce image size Pin versions for base images and dependencies Minimize layers by combining RUN commands Use smallest suitable base image (e.g., Alpine Linux)","title":"14. Dockerfile Best Practices"},{"location":"docker/docker/#15-cleanup-commands","text":"docker system prune # Remove unused objects docker system prune -a # Remove all unused images docker volume prune # Remove unused volumes docker network prune # Remove unused networks docker rm $(docker ps -aq) # Remove all stopped containers","title":"15. Cleanup Commands"},{"location":"docker/docker/#16-conclusion-why-docker-is-essential","text":"Docker has become fundamental to modern DevOps because it: Standardizes application packaging and deployment Enables microservices architecture Facilitates CI/CD pipelines Improves development/production parity Optimizes resource utilization Simplifies scaling and orchestration (with Kubernetes) When combined with Kubernetes, Docker provides a complete solution for building, shipping, and running distributed applications at scale.","title":"16. Conclusion: Why Docker is Essential"},{"location":"k8s/k8s/","text":"1. What is Kubernetes? Kubernetes, often abbreviated as K8s. It is an open-source platform designed to automate the deployment, scaling, and management of containerized applications. It groups containers that make up an application into logical units for easy management and discovery. Purpose of Container Orchestration In modern software development, applications are increasingly built using containers (like Docker). While containers solve the works on my machine problem and provide isolation, managing many containers across multiple servers (a cluster) becomes complex. This is where container orchestration comes in: Deployment Automation: Automates the process of getting your application containers running on a cluster. Scaling: Automatically adjusts the number of container instances based on demand, ensuring performance and availability. Self-Healing: Automatically restarts failed containers, replaces unhealthy ones, and reschedules containers on healthy nodes. Load Balancing: Distributes incoming traffic across multiple container instances to ensure even load. Resource Management: Efficiently allocates compute resources (CPU, memory) to containers across the cluster. Service Discovery: Allows containers to find and communicate with each other easily. Configuration Management: Manages application configurations and sensitive data securely. Comparison: Docker vs Kubernetes It's a common misconception that Docker and Kubernetes are competing technologies. In reality, they often complement each other. Feature Docker (Engine/CLI) Kubernetes Primary Role Containerization platform (build, run, share containers) Container Orchestration (manage, scale, deploy containers) Scope Single host (primarily) Cluster of hosts (distributed systems) Focus Packaging applications into portable units Managing the lifecycle of many containers at scale Deployment docker run on a single machine Automated deployment across a cluster Scaling Manual scaling (e.g., docker run multiple times) Automatic scaling based on policies Self-Healing Limited (e.g., restart policy) Robust (restarts, reschedules, replaces failed containers) Networking Basic networking for containers on a single host Advanced networking for inter-container communication across cluster Load Balancing Manual or requires external tools Built-in load balancing and service discovery Configuration Environment variables, bind mounts ConfigMaps, Secrets, Volumes Complexity Relatively simple for single-container apps Higher initial learning curve, powerful for complex apps Typical Usage Local development, running single services Production deployments of microservices, distributed apps \ud83e\udde0 Analogy: If Docker is the engine for your car (application), then Kubernetes is the traffic management system that ensures all cars on the road (applications) reach their destination efficiently and safely. 2. Kubernetes Architecture Kubernetes operates on a master-worker architecture. A Kubernetes cluster consists of at least one Master Node and multiple Worker Nodes. Diagram: Master Node Components The Master Node (also called Control Plane ) manages the cluster and ensures that it remains in the desired state. It includes the following components: kube-apiserver Purpose : The front-end for the Kubernetes control plane. All communication with the cluster (from kubectl or other components) goes through the API server. Role : Exposes the Kubernetes API, handles REST operations, validates requests, and updates etcd . Interaction : It's the only component that directly talks to etcd . etcd Purpose : A consistent and highly available key-value store that holds all cluster data (cluster state, configuration, metadata). Role : The single source of truth for the Kubernetes cluster. Interaction : Only the kube-apiserver accesses etcd . kube-scheduler Purpose : Watches for newly created Pods that do not have an assigned node and selects a node for them to run on. Role : Considers resource requirements, hardware/software/policy constraints, affinity/anti-affinity rules, and data locality. kube-controller-manager Purpose : Runs controller processes. Controllers are control loops that watch the shared state of the cluster via the API server and make changes to drive the current state towards the desired state. Role : Manages various controllers: Node Controller : Detects and responds when nodes go down. Replication Controller : Ensures the correct number of Pods are maintained for each ReplicaSet or ReplicationController. Endpoints Controller : Populates the Endpoints object (connecting Services and Pods). Service Account & Token Controllers : Creates default service accounts and API access tokens for new namespaces. Worker Node Components Worker Nodes (also called Minions or just Nodes ) run the actual containerized applications. Kubelet Purpose : An agent that runs on 3. Kubernetes Core Concepts Understanding these fundamental building blocks is crucial for working with Kubernetes. Pod Definition : The smallest deployable unit in Kubernetes. A Pod represents a single instance of a running process in your cluster. Characteristics: Atomic Unit : Can contain one or more tightly coupled containers that share the same network namespace, IP address, and storage. Ephemeral : Pods are designed to be short-lived. If a Pod dies, Kubernetes creates a new one. Shared Resources : Containers share localhost, networking stack (IP, ports), and volumes. Analogy : A Pod is like a small logical machine that hosts your app\u2019s components. When to use multiple containers in a Pod? Use for sidecar containers (e.g., logging agent, data syncer, proxy) that support the main container. ReplicaSet Definition : Ensures a specified number of Pod replicas are running at all times. Purpose : Maintains availability and scaling. Replaces failed Pods, removes excess. Usage : Typically managed through Deployments , not directly created. Deployment Definition : A higher-level abstraction for managing ReplicaSets and Pods declaratively. Purpose : Manages the desired state (e.g., number of replicas, Pod version). Key Features: Rolling Updates : Update with zero downtime. Rollbacks : Revert to previous versions if needed. Scaling : Scale the number of replicas up or down. Analogy : Deployment is like a project manager for your app, ensuring correct versioning and scaling. Service Definition : An abstraction that exposes a set of Pods as a network service. Purpose : Provides a stable IP/DNS name and acts as a load balancer. Types of Services: ClusterIP (default) Internal-only access. Use for backend/internal services. NodePort Exposes service on each node\u2019s static port. Access via NodeIP:NodePort . Use for testing/dev environments. LoadBalancer Externally accessible via a cloud load balancer (e.g., AWS ELB). Use for production-grade public apps. ExternalName Maps service to an external DNS name (e.g., my.db.example.com ). No proxying \u2014 returns a CNAME record. Analogy : A Service is like a stable phone number \u2014 callers reach your app even if Pods change. Namespace Definition : Provides a scope for resource names. Useful for isolating resources between teams or environments. Purpose : Logical partitioning of resources. Default Namespaces: default : For general workloads. kube-system : Kubernetes system resources. kube-public : Public resources. kube-node-lease : Node heartbeat tracking. Best Practice : Use separate Namespaces for dev, staging, production, and teams. ConfigMap & Secret ConfigMap: Definition : Stores non-confidential config data as key-value pairs. Purpose : Decouple configuration from code. Usage : As environment variables, command args, or mounted files. Secret: Definition : Stores sensitive data like passwords, tokens, keys. Purpose : Securely handle confidential information. Security : Base64 encoded by default. Enable encryption for production. Usage : Similar to ConfigMaps, but for secret data. Best Practice : Never store secrets in ConfigMaps. Volume & PersistentVolumeClaim (PVC) Volume: Definition : A directory accessible to containers in a Pod. Purpose : Shares data between containers or persists data beyond container lifespan. Basic Volume Types: emptyDir : Temporary storage, tied to Pod life. hostPath : Mounts node\u2019s file path (not recommended in production). PersistentVolume (PV): Definition : Pre-provisioned storage in the cluster. Purpose : Durable, cluster-level storage. PersistentVolumeClaim (PVC): Definition : User request for PV. Purpose : Abstracts storage request from underlying storage. Analogy : PV is like a raw hard drive, PVC is the user\u2019s storage request, and Volume is the Pod\u2019s access point. Other Workload Resources DaemonSet Purpose : Ensures a Pod runs on all (or some) nodes. Use Case : Cluster-wide agents (e.g., log collectors, metrics exporters). StatefulSet Purpose : Manages stateful applications. Use Case : Databases (e.g., MySQL, Kafka) needing stable identities and storage. Job Purpose : Creates Pods that run to completion. Use Case : One-off or batch tasks (e.g., report generation). CronJob Purpose : Runs Jobs on a schedule (like Unix cron). Use Case : Periodic backups, scheduled reports. 4. Kubernetes Objects and YAML Syntax Kubernetes resources are defined using YAML ( YAML Ain't Markup Language ) files. These files describe the desired state of objects in your cluster. Anatomy of a Kubernetes Manifest Every Kubernetes YAML manifest generally contains four top-level fields : 1. apiVersion What it is : Specifies which version of the Kubernetes API you're using. Examples : v1 (for core resources like Pod, Service) apps/v1 (for Deployments, StatefulSets) batch/v1 (for Jobs, CronJobs) 2. kind What it is : The type of Kubernetes object being created. Examples : Pod , Deployment , Service , ConfigMap , PersistentVolumeClaim 3. metadata What it contains : name : Unique name of the object within a Namespace. namespace : (Optional) Scope of the resource. Defaults to default if not specified. labels : Key-value pairs used for organization and selection. annotations : Additional metadata (non-identifying, like build version or tool info). 4. spec What it is : Defines the desired state of the object. Note : The structure under spec depends on the object's kind . Example Basic YAML Structure apiVersion: <api-version> kind: <kind-of-object> metadata: name: <object-name> namespace: <optional-namespace> labels: app: <application-name> tier: <tier-name> spec: # Desired state of the object (varies by kind) Example YAML Files These YAML files define various Kubernetes resources like Pods, Deployments, Services, ConfigMaps, and PVCs. \ud83e\uddf1 Pod Example # my-pod.yaml apiVersion: v1 kind: Pod metadata: name: my-nginx-pod labels: app: web tier: frontend spec: containers: - name: nginx-container image: nginx:latest ports: - containerPort: 80 Deployment Example # my-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: my-web-deployment labels: app: web spec: replicas: 3 # Desired number of Pod replicas selector: matchLabels: app: web # Selects Pods with label app: web template: # Pod template metadata: labels: app: web version: v1.0.0 spec: containers: - name: nginx-container image: nginx:1.21.6 ports: - containerPort: 80 resources: # Optional: Define resource requests and limits requests: memory: \"64Mi\" cpu: \"250m\" # 0.25 CPU core limits: memory: \"128Mi\" cpu: \"500m\" # 0.5 CPU core Service Example (NodePort) # my-service.yaml apiVersion: v1 kind: Service metadata: name: my-web-service labels: app: web spec: selector: app: web # Selects Pods with label app: web type: NodePort # Exposes service on a static port on each node ports: - protocol: TCP port: 80 # Service port (internal) targetPort: 80 # Container port nodePort: 30007 # Optional: Specific node port (range 30000-32767) ConfigMap Example # my-configmap.yaml apiVersion: v1 kind: ConfigMap metadata: name: app-config data: # Key-value pairs for configuration APP_COLOR: blue APP_ENV: development database.url: jdbc:mysql://localhost:3306/mydb PersistentVolumeClaim (PVC) Example # my-pvc.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: my-data-pvc spec: accessModes: - ReadWriteOnce # Can be mounted as read-write by a single node resources: requests: storage: 5Gi # Request 5 Gigabytes of storage # storageClassName: standard # Optional: If you have a specific StorageClass 5. Kubernetes CLI (kubectl) kubectl is the command-line tool for interacting with Kubernetes clusters. \ud83d\udd0c Cluster Interaction kubectl communicates with the kube-apiserver on the Control Plane (Master Node). \ud83d\udee0\ufe0f Common kubectl Commands (Grouped by Function) \u2705 Creation & Application Apply a configuration (create or update): kubectl apply -f <filename.yaml> kubectl apply -f <directory_containing_yamls>/ # Example: kubectl apply -f my-deployment.yaml Best Practice: Always use kubectl apply for managing resources, as it's idempotent (can be run multiple times safely). Create a resource (if it doesn't exist): kubectl create -f <filename.yaml> # Creates only if resource doesn't exist kubectl create deployment my-app --image=nginx # Quick imperitive command Note: kubectl create is generally used for initial setup or one-off resources . kubectl apply is preferred for declarative, version-controlled resource management . \ud83d\udd0d Getting Information List resources: kubectl get pods kubectl get deployments kubectl get services kubectl get all # Get common resources (pods, services, deployments, replicasets) kubectl get pods -o wide # Show more details (Node IP, Pod IP) kubectl get pods -n <namespace> # Get pods in a specific namespace kubectl get pods --show-labels # Show labels Describe a resource (detailed information): kubectl describe pod <pod-name> kubectl describe deployment <deployment-name> kubectl describe service <service-name> # Example: kubectl describe pod my-nginx-pod-abc12 Purpose: Shows events, status, resource limits, volumes, etc. Indispensable for troubleshooting. View logs from a container in a Pod: kubectl logs <pod-name> kubectl logs -f <pod-name> # Follow logs in real-time kubectl logs <pod-name> -c <container-name> # For multi-container pods Execute a command in a running container: kubectl exec -it <pod-name> -- /bin/bash # Get a shell into the container kubectl exec <pod-name> -- ls /app # Run a command # Example: kubectl exec -it my-nginx-pod-abc12 -- bash Copy files to/from a container: kubectl cp <source-path> <pod-name>:<destination-path> kubectl cp <pod-name>:<source-path> <destination-path> # Example: kubectl cp my-local-file.txt my-nginx-pod-abc12:/usr/share/nginx/html/ View resource usage (requires Metrics Server): kubectl top nodes kubectl top pods Check cluster events: kubectl get events Deletion: Delete a resource: kubectl delete -f <filename.yaml> kubectl delete pod <pod-name> kubectl delete deployment <deployment-name> kubectl delete service <service-name> kubectl delete namespace <namespace-name> # Deletes everything in that namespace # Example: kubectl delete -f my-deployment.yaml kubectl delete deployment my-web-deployment Scaling and Updates: Scale a Deployment: kubectl scale deployment <deployment-name> --replicas=<number> # Example: kubectl scale deployment my-web-deployment --replicas=5 Rollout status/history/undo: kubectl rollout status deployment/<deployment-name> kubectl rollout history deployment/<deployment-name> kubectl rollout undo deployment/<deployment-name> # Rollback to previous version Namespace Management: List namespaces: kubectl get namespaces Create a namespace: kubectl create namespace <namespace-name> # Example: kubectl create namespace dev-env Set default namespace for current context: kubectl config set-context --current --namespace=<namespace-name> # Example: kubectl config set-context --current --namespace=dev-env This makes your infrastructure version-controllable and repeatable. Best Practices for kubectl Declarative vs. Imperative : While imperative commands ( kubectl run , kubectl create deployment ) are useful for quick tests, prefer declarative management using YAML files with: kubectl apply -f <file.yaml> This makes your infrastructure version-controllable and repeatable. \ud83d\udcdb Namespaces Always specify the namespace using the -n <namespace> flag if you're not operating in the default namespace. bash kubectl get pods -n dev \ud83c\udff7\ufe0f Labels Use labels extensively for organizing and selecting Kubernetes resources. Labels are key-value pairs used to categorize resources. They enable filtering, selection, and grouping for operations like deployments, services, and monitoring. Example (YAML): metadata: labels: app: my-app environment: dev \ud83d\udee0\ufe0f Describe for Troubleshooting When something isn't working, kubectl describe should be your first stop . It provides detailed insights into the resource's current state. Useful information includes: Events and warnings Pod scheduling and status Liveness/readiness probe results Volume mounts and conditions Example: kubectl describe pod my-app-pod \ud83d\udcc4 Logs for Application Insights Use kubectl logs to check logs and understand application behavior . Examples: kubectl logs <pod-name> kubectl logs -f <pod-name> # Follow logs in real time kubectl logs <pod-name> -c <container> # For multi-container Pods 6. Kubernetes Networking Kubernetes networking enables communication between Pods, Services, and the outside world. It's a complex topic, but here's a simplified overview. Key Principles: Every Pod gets its own unique IP address. Pods on a node can communicate with all Pods on all other nodes without NAT. Agents on a node (e.g., kubelet) can communicate with all Pods on that node. Pod-to-Pod Communication When Pods are on the same Node : They communicate directly using their Pod IP addresses. When Pods are on different Nodes : Traffic is routed between nodes by the underlying Container Network Interface (CNI) plugin (e.g., Calico, Flannel, Weave Net). Each Pod has a unique IP address within the cluster, and these IPs are routable across the cluster. Service-to-Service Communication Services provide a stable IP address and DNS name for a set of Pods. Pods communicate with each other via Services using the Service's stable IP address or DNS name. kube-proxy on each node ensures that traffic sent to a Service's IP is correctly load-balanced to the healthy Pods backing that Service. Example : A frontend Pod wants to talk to a backend Pod. Instead of knowing the backend Pod's ephemeral IP, it sends traffic to the backend-service name or IP, and Kubernetes handles the routing and load balancing. DNS Resolution Kubernetes provides internal DNS resolution. Services are automatically assigned DNS names. Within the same Namespace : service-name Across Namespaces : service-name.namespace-name.svc.cluster.local This allows Pods to discover and communicate with Services by name rather than by IP address. Network Policies (Basic Intro) Definition : Kubernetes Network Policies specify how groups of Pods are allowed to communicate with each other and with external network endpoints. Purpose : Enhance security by restricting network access between Pods. By default, Pods are non-isolated and can accept traffic from any source. Requirement : Network Policies require a CNI plugin that supports them (e.g., Calico, Cilium). Analogy : Network Policies are like firewall rules for your Pods. 7. Kubernetes Storage Kubernetes provides robust mechanisms for managing storage, allowing applications to persist data beyond the life of a single container or Pod. Types of Volumes Kubernetes Volumes are directories accessible to the containers in a Pod. The data in a Volume persists as long as the Pod exists. Some common types: emptyDir : Purpose : A simple, empty volume created when a Pod is first assigned to a node. Persistence : Its contents are deleted when the Pod is removed from the node. Use Case : Temporary scratch space, sharing files between containers in the same Pod. hostPath : Purpose : Mounts a file or directory from the host node's filesystem into a Pod. Persistence : Data persists beyond Pod lifecycle, but tied to a specific node. Use Case : Primarily for system-level Pods (e.g., monitoring agents), or if you need access to host files. Caution : Generally discouraged for production applications due to lack of portability and potential security risks. persistentVolume (PV) and persistentVolumeClaim (PVC) : (Covered in Section 3) PV : A piece of storage in the cluster, provisioned by an admin (or dynamically). PVC : A request for storage by a user, that binds to an available PV. Purpose : Provides a way to consume durable storage abstractly. Use Case : Databases, persistent application data. StorageClasses (Basic Overview) Definition : An API object that describes the \"classes\" of storage offered in a cluster. Purpose : Allows administrators to define different types of storage (e.g., \"fast-SSD\", \"cheap-HDD\", \"network-storage\") and users to request them without knowing the underlying storage details. Dynamic Provisioning : When a PVC requests a storageClassName , the StorageClass can dynamically provision a matching PV for that PVC. Analogy : StorageClass is like a catalog of storage options, and PVC is like ordering from that catalog. 8. Kubernetes Services Comparison Table Here's a comparison of the main Service types in Kubernetes, including Ingress for external access. Feature ClusterIP NodePort LoadBalancer Ingress Exposure Internal to cluster On each Node's IP at a static port External IP provisioned by cloud provider HTTP/HTTPS routing based on host/path Accessibility Only from within the cluster From outside the cluster (via NodeIP:NodePort) From anywhere on the internet From anywhere on the internet (via DNS of Ingress controller) Load Balancing Internal ( kube-proxy ) Internal ( kube-proxy ) External (cloud provider's LB) Application-layer (L7) (Ingress controller) Cost Free Free Varies by cloud provider (often charged) Requires Ingress Controller (potentially charged for underlying LB) Complexity Low Low Moderate (requires cloud provider setup) Moderate to High (requires Ingress Controller setup) Use Cases Internal microservices, backend services Demo/testing, non-production apps, exposing a few services Production apps in cloud, public APIs Production web apps (HTTP/HTTPS), multiple services on single IP, SSL termination DNS Internal DNS name Internal DNS name + NodeIP/NodePort External IP + Internal DNS name External DNS name (for Ingress Host) 9. Kubernetes Ingress While Services expose applications, Ingress is designed for managing external access to services in a cluster, typically HTTP and HTTPS. Ingress Controller and Ingress Resource Ingress Controller: Definition : An application that runs in your cluster and watches the Kubernetes API for Ingress resources. Purpose : Fulfills the Ingress rules by acting as a reverse proxy/load balancer. Common Ingress Controllers include Nginx Ingress Controller, Traefik, Istio, GKE Ingress, AWS ALB Ingress Controller. Deployment : The Ingress Controller itself is typically deployed as a Deployment and exposed via a NodePort or LoadBalancer Service. Ingress Resource: Definition : A Kubernetes API object that defines rules for routing external HTTP/HTTPS traffic to Services within the cluster. Purpose : Provides flexible routing based on hostname, path, and TLS termination. Analogy : The Ingress Controller is the actual traffic cop, and the Ingress Resource is the rulebook that tells the traffic cop how to direct traffic. Ingress Architecture: Basic Ingress YAML Example This example routes traffic for myapp.example.com/api to api-service and myapp.example.com/ to frontend-service . #### my-ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-app-ingress annotations: # Example annotation for Nginx Ingress Controller: nginx.ingress.kubernetes.io/rewrite-target: / spec: rules: - host: myapp.example.com http: paths: - path: /api pathType: Prefix backend: service: name: api-service # Name of your API Service port: number: 8080 - path: / pathType: Prefix backend: service: name: frontend-service # Name of your Frontend Service port: number: 80 # Optional: TLS/SSL termination # tls: # - hosts: # - myapp.example.com # secretName: my-app-tls-secret # Secret containing TLS certificate and key Note: You must have an Ingress Controller running in your cluster for Ingress resources to work. 10. Helm Basics Helm is a package manager for Kubernetes. It simplifies the deployment and management of applications on Kubernetes clusters. What is Helm? Definition : The \"apt/yum/brew\" for Kubernetes. Purpose : Helps you define, install, and upgrade even the most complex Kubernetes applications. Key Concepts: Charts : Pre-configured Kubernetes resource packages. Repositories : Places where charts are stored and shared. Releases : An instance of a chart running in a Kubernetes cluster. Helm Charts and their Structure A Helm Chart is a collection of files that describe a related set of Kubernetes resources. Think of it as a template for a Kubernetes application. Typical Chart Structure: Helm Chart Structure: my-app-chart/ my-app-chart/ \u251c\u2500\u2500 Chart.yaml # A YAML file containing information about the chart (name, version, etc.) \u251c\u2500\u2500 values.yaml # Default configuration values for the chart \u251c\u2500\u2500 templates/ # Directory containing Kubernetes manifest templates \u2502 \u251c\u2500\u2500 deployment.yaml # Template for a Deployment object \u2502 \u251c\u2500\u2500 service.yaml # Template for a Service object \u2502 \u251c\u2500\u2500 _helpers.tpl # Optional: Contains reusable template snippets \u2502 \u2514\u2500\u2500 NOTES.txt # Optional: Instructions for the user after installation \u251c\u2500\u2500 charts/ # Optional: Contains dependent charts (subcharts) \u2514\u2500\u2500 README.md # Optional: A brief description of the chart Installing and Using Helm Commands Install Helm CLI: macOS (Homebrew): brew install helm Linux: Download from helm.sh or use package manager. Add a Chart Repository (e.g., Bitnami stable charts): helm repo add bitnami https://charts.bitnami.com/bitnami helm repo update # Update information about charts from all repositories Search for Charts: helm search repo nginx Install a Chart: helm install <release-name> <chart-name> --namespace <namespace> --values <your-values.yaml> # Example: Install Nginx Ingress Controller helm install my-nginx-ingress bitnami/nginx-ingress-controller --namespace ingress-nginx # Example: Install WordPress helm install my-wordpress bitnami/wordpress --set mysql.rootPassword=mysecretpassword --namespace blog --set: Override specific values from values.yaml directly on the command line. --values: Provide an entire custom values.yaml file. List Releases: helm list helm list -n <namespace> Upgrade a Release: helm upgrade <release-name> <chart-name> --namespace <namespace> --values <your-new-values.yaml> # Example: helm upgrade my-wordpress bitnami/wordpress -f my-new-wordpress-values.yaml Uninstall a Release: helm uninstall <release-name> --namespace <namespace> # Example: helm uninstall my-wordpress -n blog Get Release Status: helm status <release-name> -n <namespace> Lint a Chart (check for best practices and syntax errors): helm lint ./my-app-chart Package a Chart: helm package ./my-app-chart 11. Kubernetes Security Basics Security is paramount in Kubernetes. Here are fundamental concepts. Role-Based Access Control (RBAC) Purpose: Authorizes users and applications to interact with the Kubernetes API. Concepts: Role: Defines a set of permissions within a specific Namespace (e.g., \"can read Pods\" or \"can manage Deployments\"). ClusterRole: Similar to a Role, but applies across the entire cluster (non-namespaced resources like Nodes or PersistentVolumes, or namespaced resources across all Namespaces). RoleBinding: Grants the permissions defined in a Role to a user, group, or ServiceAccount within a specific Namespace. ClusterRoleBinding: Grants the permissions defined in a ClusterRole to a user, group, or ServiceAccount across the entire cluster. Analogy: RBAC is like defining roles in an organization (e.g., \"Manager,\" \"Developer\") and then assigning those roles to specific people or teams. ServiceAccount Definition: Provides an identity for processes that run in a Pod. Purpose: Allows Pods to authenticate to the Kubernetes API server when they need to perform actions (e.g., a controller that watches for new resources). Default: Every Pod automatically gets a default ServiceAccount in its Namespace, which usually has limited permissions. Best Practice: Create specific ServiceAccounts with the minimal necessary permissions for your applications. Network Policies Purpose: (As discussed in Section 6) Control Pod-to-Pod communication using firewall rules. By default, Pods are open. Network Policies allow you to isolate them. Best Practice: Implement Network Policies to restrict traffic flows to only what is necessary, following the principle of least privilege. Secrets and ConfigMaps (Best Practices) Secrets: (As discussed in Section 3) For sensitive data. Best Practice: Always use Secrets for credentials. Do not store sensitive data in ConfigMaps or directly in YAML files in version control. For production, consider external Secret management solutions (e.g., HashiCorp Vault, cloud provider KMS integrations) to avoid storing plaintext secrets in etcd or in your Kubernetes manifests. ConfigMaps: For non-confidential configuration. Best Practice: Use ConfigMaps to decouple configuration from your application images. 12. Monitoring and Logging Effective monitoring and logging are crucial for understanding the health and performance of your Kubernetes applications and cluster. Basic Health Checks - Liveness Probes : (See Section 14) Determine if a container is running and healthy. If a Liveness Probe fails, Kubernetes restarts the container. Readiness Probes : (See Section 14) Determine if a container is ready to serve traffic. If a Readiness Probe fails, the Pod is removed from Service load balancing until it becomes ready. kubectl logs and kubectl top - kubectl logs : (As discussed in Section 5) Retrieve standard output and standard error from containers. Essential for debugging application issues. kubectl top : (As discussed in Section 5) Provides basic CPU and memory usage of nodes and pods. Requires the Kubernetes Metrics Server to be installed in the cluster. Prometheus and Grafana Overview These are de-facto standards for monitoring in Kubernetes environments. Prometheus : Purpose : A powerful open-source monitoring and alerting toolkit designed for reliability and scalability. How it works : Scrapes metrics from configured targets (Kubernetes components, application endpoints) at regular intervals, stores them, and allows for querying and alerting. Grafana : Purpose : An open-source analytics and interactive visualization web application. How it works : Used to create dashboards that visualize data collected by Prometheus (or other data sources). Provides powerful querying and visualization capabilities. Typical Setup: Prometheus Server (runs in Kubernetes) scrapes metrics. Grafana (runs in Kubernetes) connects to Prometheus as a data source and displays dashboards. Node Exporter (DaemonSet) on each node exposes node-level metrics for Prometheus. kube-state-metrics (Deployment) exposes Kubernetes object metrics (e.g., Pod status, Deployment replicas). 13. Deploying a Full-Stack App (Spring Boot + Angular + MySQL) Full-Stack Application Architecture Application Components Frontend : Angular application served by Nginx Backend : Spring Boot REST API Database : MySQL Kubernetes Application Architecture User | V +---------------------+ | Internet / Browser | +---------------------+ | (HTTP/HTTPS) V +---------------------+ | Ingress Controller | +---------------------+ | |--> Host: `myapp.com/api` \u2192 Spring Boot Service |--> Host: `myapp.com/` \u2192 Angular Service V +-----------------------------------+ | Kubernetes Cluster | | | | +---------------------------+ | | | Frontend Service | | | | (ClusterIP) | | | +----+----------------------+ | | | | | V | | +---------------------------+ | | | Frontend Deployment | | | | (Nginx + Angular) | | | +---------------------------+ | | | | +---------------------------+ | | | Backend Service | | | | (ClusterIP) | | | +----+----------------------+ | | | | | V | | +---------------------------+ | | | Backend Deployment | | | | (Spring Boot) | | | +----+----------------------+ | | | | | V | | +---------------------------+ | | | MySQL Service | | | | (ClusterIP) | | | +----+----------------------+ | | | | | V | | +---------------------------+ | | | MySQL StatefulSet | | | | + PVC for Data | | | +---------------------------+ | +-----------------------------------+ YAML Manifests: We'll use a single k8s-fullstack.yaml file for simplicity. k8s-fullstack.yaml 1. MySQL Deployment (using StatefulSet for persistence) apiVersion: apps/v1 kind: StatefulSet metadata: name: mysql labels: app: mysql spec: selector: matchLabels: app: mysql serviceName: \"mysql\" # headless service for stable network identity replicas: 1 template: metadata: labels: app: mysql spec: containers: - name: mysql image: mysql:8.0 env: - name: MYSQL_ROOT_PASSWORD valueFrom: secretKeyRef: name: mysql-secret key: mysql-root-password - name: MYSQL_DATABASE valueFrom: configMapKeyRef: name: app-config key: MYSQL_DATABASE ports: - containerPort: 3306 name: mysql volumeMounts: - name: mysql-data # Mount the volume for persistent data mountPath: /var/lib/mysql volumeClaimTemplates: # Define the PVC for this StatefulSet - metadata: name: mysql-data spec: accessModes: [ \"ReadWriteOnce\" ] resources: requests: storage: 5Gi # Request 5GB of storage # storageClassName: standard # Uncomment if you have a specific StorageClass 2. MySQL Service (ClusterIP, for internal communication) apiVersion: v1 kind: Service metadata: name: mysql-service labels: app: mysql spec: ports: - port: 3306 targetPort: 3306 protocol: TCP name: mysql selector: app: mysql clusterIP: None # Headless service for StatefulSet 3. Spring Boot Backend Deployment apiVersion: apps/v1 kind: Deployment metadata: name: spring-boot-backend labels: app: backend spec: replicas: 2 selector: matchLabels: app: backend template: metadata: labels: app: backend spec: containers: - name: spring-boot-app image: yourusername/spring-boot-app:1.0.0 # Replace with your image! env: - name: SPRING_DATASOURCE_URL valueFrom: configMapKeyRef: name: app-config key: SPRING_DATASOURCE_URL - name: SPRING_DATASOURCE_USERNAME valueFrom: secretKeyRef: name: mysql-secret key: mysql-username - name: SPRING_DATASOURCE_PASSWORD valueFrom: secretKeyRef: name: mysql-secret key: mysql-password ports: - containerPort: 8080 livenessProbe: # Example liveness probe httpGet: path: /actuator/health/liveness # Adjust path for your Spring Boot app port: 8080 initialDelaySeconds: 30 periodSeconds: 10 readinessProbe: # Example readiness probe httpGet: path: /actuator/health/readiness # Adjust path port: 8080 initialDelaySeconds: 15 periodSeconds: 5 4. Spring Boot Backend Service (ClusterIP, for internal and Ingress access) apiVersion: v1 kind: Service metadata: name: backend-service labels: app: backend spec: selector: app: backend ports: - protocol: TCP port: 8080 targetPort: 8080 type: ClusterIP 5. Angular Frontend Deployment apiVersion: apps/v1 kind: Deployment metadata: name: angular-frontend labels: app: frontend spec: replicas: 2 selector: matchLabels: app: frontend template: metadata: labels: app: frontend spec: containers: - name: nginx-angular image: yourusername/angular-nginx:1.0.0 # Replace with your image! ports: - containerPort: 80 6. Angular Frontend Service (ClusterIP, for Ingress access) apiVersion: v1 kind: Service metadata: name: frontend-service labels: app: frontend spec: selector: app: frontend ports: - protocol: TCP port: 80 targetPort: 80 type: ClusterIP 7. ConfigMap for application configuration apiVersion: v1 kind: ConfigMap metadata: name: app-config data: MYSQL_DATABASE: myappdb SPRING_DATASOURCE_URL: jdbc:mysql://mysql-service:3306/myappdb?useSSL=false&allowPublicKeyRetrieval=true 8. Secret for sensitive data (base64 encoded) # Create secrets first: # echo -n 'root_password_here' | base64 # echo -n 'myuser' | base64 # echo -n 'mypassword' | base64 apiVersion: v1 kind: Secret metadata: name: mysql-secret type: Opaque data: mysql-root-password: <base64_encoded_root_password> # e.g., cG9zdGdyZXNfcGFzc3dvcmRfaGVyZQ== mysql-username: <base64_encoded_db_username> mysql-password: <base64_encoded_db_password> 9. Ingress for external routing apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-app-ingress annotations: # Use appropriate annotations for your Ingress Controller (e.g., Nginx, AWS ALB) # For Nginx Ingress Controller: nginx.ingress.kubernetes.io/rewrite-target: /$2 # For path stripping if needed nginx.ingress.kubernetes.io/ssl-redirect: \"false\" # Optional, if not using HTTPS spec: ingressClassName: nginx # Required for Kubernetes v1.18+ rules: - host: myapp.example.com # Replace with your domain http: paths: - path: /api(/|$)(.*) # Route traffic for /api to backend pathType: Prefix backend: service: name: backend-service port: number: 8080 - path: /(.*) # Route all other traffic to frontend pathType: Prefix backend: service: name: frontend-service port: number: 80 # Uncomment and configure TLS if you have a certificate secret # tls: # - hosts: # - myapp.example.com # secretName: myapp-tls-secret # Create this secret with 'kubectl create secret tls myapp-tls-secret --key private.key --cert certificate.crt' Deployment Steps: Build and push your Docker images: docker build -t yourusername/spring-boot-app:1.0.0 ./spring-boot-app docker push yourusername/spring-boot-app:1.0.0 docker build -t yourusername/angular-nginx:1.0.0 ./angular-nginx docker push yourusername/angular-nginx:1.0.0 Create your mysql-secret: kubectl create secret generic mysql-secret \\ --from-literal=mysql-root-password='your_root_password' \\ --from-literal=mysql-username='myuser' \\ --from-literal=mysql-password='mypassword' Apply the full-stack YAML: kubectl apply -f k8s-fullstack.yaml Verify Deployments and Services: kubectl get deployments kubectl get pods kubectl get services kubectl get pvc kubectl get ingress Access the application: If using a cloud provider, the LoadBalancer for your Ingress Controller will get an external IP. Update your DNS A record for myapp.example.com to point to the Ingress LoadBalancer IP. Alternatively, if using NodePort for Ingress Controller, access via NodeIP:NodePort. 14. Kubernetes Best Practices Adopting these practices ensures robust, scalable, and maintainable applications in Kubernetes. Liveness and Readiness Probes Liveness Probe: Purpose: Tells Kubernetes when to restart a container. If the Liveness Probe fails, Kubernetes knows the container is unhealthy and will terminate and restart it. Configuration: httpGet, tcpSocket, or exec command. Example (in Pod/Deployment spec): livenessProbe: httpGet: path: /healthz port: 8080 initialDelaySeconds: 15 # Wait 15s before first check periodSeconds: 10 # Check every 10s timeoutSeconds: 5 # Timeout after 5s failureThreshold: 3 # Restart after 3 failed attempts Readiness Probe: Purpose: Tells Kubernetes when a container is ready to serve traffic. If the Readiness Probe fails, the Pod is removed from the Service's endpoints (no traffic is sent to it) until it becomes ready. Configuration: httpGet, tcpSocket, or exec command. Example (in Pod/Deployment spec): readinessProbe: httpGet: path: /ready port: 8080 initialDelaySeconds: 5 periodSeconds: 5 timeoutSeconds: 3 failureThreshold: 1 # Unready after 1 failed attempt Difference: Liveness deals with \"should I restart this container?\" , Readiness deals with \"is this container ready to accept requests?\". Resource Limits and Requests Purpose: Crucial for efficient resource allocation and cluster stability. requests: The minimum amount of CPU and memory a container needs. Kubernetes uses this for scheduling decisions (ensures a node has enough resources available). limits: The maximum amount of CPU and memory a container can use. If a container exceeds its memory limit, it's terminated. If it exceeds its CPU limit, it's throttled. Example (in container spec): resources: requests: memory: \"256Mi\" cpu: \"500m\" # 0.5 CPU core limits: memory: \"512Mi\" cpu: \"1000m\" # 1 CPU core Best Practice: Always define requests and limits for your production workloads. Separation by Namespaces Purpose: (As discussed in Section 3) Logical isolation within a cluster. Best Practice: Create separate Namespaces for different environments (e.g., dev, staging, prod). Create separate Namespaces for different teams or applications. Facilitates RBAC, Network Policies, and resource quotas. Auto-scaling with Horizontal Pod Autoscaler (HPA) Purpose: Automatically scales the number of Pod replicas in a Deployment or ReplicaSet based on observed CPU utilization or other custom metrics. How it works: HPA continuously monitors metrics and adjusts the replicas field of the target resource. Example: apiVersion: autoscaling/v2 kind: HorizontalPodAutoscaler metadata: name: my-web-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: my-web-deployment # Target Deployment to scale minReplicas: 2 maxReplicas: 10 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 # Target 70% average CPU utilization # - type: Resource # Example for memory # resource: # name: memory # target: # type: AverageValue # averageValue: 200Mi ``` Best Practice: Use HPA to ensure your application can handle varying loads efficiently. Requires the Metrics Server. ## 15. Cleanup and Maintenance Regular cleanup and maintenance are essential for keeping your Kubernetes cluster healthy and cost-efficient. Commands to Delete Resources Delete by file: ```Bash kubectl delete -f <filename.yaml> Delete by type and name: kubectl delete deployment <deployment-name> kubectl delete service <service-name> kubectl delete pod <pod-name> --grace-period=0 --force # Force delete a stuck pod kubectl delete pvc <pvc-name> kubectl delete pv <pv-name> # Careful! Ensure no PVCs are using it. Delete multiple resources by label: kubectl delete pods -l app=nginx Delete all resources of a type in a namespace: kubectl delete all --all -n <namespace> # Deletes all common resources (deployments, services, pods, etc.) Delete a Namespace and all its contents: kubectl delete namespace <namespace-name> Cleaning Up Cluster Resources Pruning unused resources (Disk space): docker system prune -a # On your node if Docker is container runtime, to clean up unused images/containers Note: This is usually done at the Docker daemon level on individual nodes, not directly kubectl. Kubernetes itself manages the lifecycle of its objects. Deleting PersistentVolumes: When you delete a PVC, the corresponding PV might not be automatically deleted. Check the Reclaim Policy of the PV (e.g., Retain, Recycle, Delete). If Retain, you must manually delete the PV after the PVC is gone. kubectl get pv kubectl delete pv <pv-name> Inspecting Pods Check Pod status: kubectl get pods Common statuses: Running, Pending, ContainerCreating, Error, CrashLoopBackOff. Get detailed information for a specific Pod: kubectl describe pod <pod-name> Look at Events section for common issues (e.g., FailedScheduling, ImagePullBackOff, LivenessProbe failed). Check Pod logs: kubectl logs <pod-name> 16. Comparison Tables Docker Compose vs Kubernetes Feature Docker Compose Kubernetes Primary Use Local development, single-host multi-container apps Production deployments, large-scale distributed systems Orchestration Basic (starts/stops linked containers) Advanced (auto-scaling, self-healing, rolling updates) Scalability Manual scaling on a single host ( docker-compose up --scale ) Automatic scaling across a cluster High Availability Limited to single host, no automatic failover Built-in HA, automatic failover of workloads Complexity Simpler, faster to set up for small projects Higher learning curve, more powerful and flexible Deployment Unit Service (defined in docker-compose.yml ) Pod (managed by Deployments, StatefulSets, etc.) Networking Bridge networks between services on single host Complex networking across multiple nodes, CNI plugins Storage Docker volumes, bind mounts PV/PVC, StorageClasses, various volume types Security Basic (user/group permissions, Docker security) Robust RBAC, Network Policies, Secrets management Tools docker compose CLI kubectl CLI, Helm, dashboard, cloud provider tools Ideal For Quick local dev, small projects, PoCs Microservices, enterprise-grade applications, cloud-native ReplicaSet vs Deployment vs StatefulSet Feature ReplicaSet Deployment StatefulSet Primary Purpose Ensure desired number of Pod replicas Declarative updates and management of Pods/ReplicaSets Manage stateful applications with stable identity Pod Identity No stable identity (random Pod names) No stable identity (random Pod names) Stable, unique network identifiers (e.g., mysql-0 ) Pod Ordering No guaranteed ordering for creation/deletion No guaranteed ordering for creation/deletion Guaranteed ordered, graceful deployment/deletion Persistent Storage Can use PVCs, but Pod-to-PVC mapping is not stable Can use PVCs, but Pod-to-PVC mapping is not stable Each Pod gets its own dedicated, stable PVC (via volumeClaimTemplates ) Use Case Underlying controller for Deployments Stateless applications, web servers, APIs Databases, message queues (Kafka), distributed systems Updates Managed by Deployment for rolling updates Built-in rolling updates, rollbacks Ordered, graceful rolling updates and scaling Scale Down Behavior Arbitrary Pods are removed Arbitrary Pods are removed Pods are terminated in reverse ordinal order Export to Sheets 17. CLI Commands Grouped by Function This section consolidates kubectl commands for quick reference. General Cluster Information kubectl version Display Kubernetes client and server versions. kubectl cluster-info Display information about the cluster master and services. kubectl config view Display merged kubeconfig settings. kubectl get nodes List cluster nodes. kubectl describe node <node-name> Show detailed information about a node. kubectl top nodes Show CPU/memory usage for nodes (requires Metrics Server). Resource Management (CRUD operations) Create kubectl apply -f <filename.yaml> Create or update resources defined in a YAML file. (Preferred for declarative management) kubectl create -f <filename.yaml> Create resources if they don't exist. kubectl create deployment <name> --image=<image> Imperatively create a Deployment. kubectl create service <type> <name> --tcp=<port>:<target-port> Imperatively create a Service. kubectl create namespace <name> Create a Namespace. kubectl create configmap <name> --from-literal=<key>=<value> Create a ConfigMap from literals. kubectl create secret generic <name> --from-literal=<key>=<value> Create a Secret from literals. kubectl create secret tls <name> --key=<key-file> --cert=<cert-file> Create a TLS Secret. Get (List) kubectl get all List common resources (pods, deployments, services, replicasets). kubectl get pods List Pods. kubectl get deployments List Deployments. kubectl get services List Services. kubectl get ingress List Ingress resources. kubectl get configmaps List ConfigMaps. kubectl get secrets List Secrets. kubectl get pvc List PersistentVolumeClaims. kubectl get pv List PersistentVolumes. kubectl get namespaces List Namespaces. kubectl get daemonsets List DaemonSets. kubectl get statefulsets List StatefulSets. kubectl get jobs List Jobs. kubectl get cronjobs List CronJobs. kubectl get <resource-type> -n <namespace> Get resources in a specific Namespace. kubectl get <resource-type> -o wide Get resources with more details. kubectl get <resource-type> -l <key>=<value> Get resources filtered by label. kubectl get <resource-type> -o yaml Get resource in YAML format (useful for inspecting current state). Describe (Detailed Information) kubectl describe pod <pod-name> Describe a Pod. kubectl describe deployment <deployment-name> Describe a Deployment. kubectl describe service <service-name> Describe a Service. kubectl describe configmap <configmap-name> Describe a ConfigMap. kubectl describe secret <secret-name> Describe a Secret. kubectl describe pvc <pvc-name> Describe a PVC. kubectl describe pv <pv-name> Describe a PV. kubectl describe ing <ingress-name> Describe an Ingress. Delete kubectl delete -f <filename.yaml> Delete resources defined in a YAML file. kubectl delete pod <pod-name> Delete a Pod. kubectl delete deployment <deployment-name> Delete a Deployment. kubectl delete service <service-name> Delete a Service. kubectl delete ingress <ingress-name> Delete an Ingress. kubectl delete namespace <namespace-name> Delete a Namespace (and all resources within it). kubectl delete all --all -n <namespace> Delete all common resources in a Namespace. kubectl delete pods -l app=my-app Delete Pods by label. Debugging and Troubleshooting kubectl logs <pod-name> Print the logs for a container in a Pod. kubectl logs -f <pod-name> Stream (follow) logs. kubectl logs <pod-name> -c <container-name> Get logs from a specific container in a multi-container Pod. kubectl exec -it <pod-name> -- /bin/bash Execute a shell inside a running container. kubectl cp <source-path> <pod-name>:<destination-path> Copy files into a container. kubectl cp <pod-name>:<source-path> <destination-path> Copy files out of a container. kubectl port-forward <pod-name> <local-port>:<container-port> Forward a local port to a port on a Pod. kubectl get events List recent events in the cluster. Scaling and Updates kubectl scale deployment <deployment-name> --replicas=<number> Scale a Deployment to a specific number of replicas. kubectl autoscale deployment <deployment-name> --min=1 --max=5 --cpu-percent=70 Create an HPA (Horizontal Pod Autoscaler). kubectl rollout status deployment/<deployment-name> Check the status of a deployment rollout. kubectl rollout history deployment/<deployment-name> View rollout history. kubectl rollout undo deployment/<deployment-name> Rollback to the previous deployment version. kubectl set image deployment/<deployment-name> <container-name>=<new-image> Update container image in a deployment. Context and Configuration kubectl config get-contexts List available contexts. kubectl config use-context <context-name> Switch to a specific context. kubectl config set-context --current --namespace=<namespace-name> Set the default Namespace for the current context.","title":"k8s"},{"location":"k8s/k8s/#1-what-is-kubernetes","text":"Kubernetes, often abbreviated as K8s. It is an open-source platform designed to automate the deployment, scaling, and management of containerized applications. It groups containers that make up an application into logical units for easy management and discovery.","title":"1. What is Kubernetes?"},{"location":"k8s/k8s/#purpose-of-container-orchestration","text":"In modern software development, applications are increasingly built using containers (like Docker). While containers solve the works on my machine problem and provide isolation, managing many containers across multiple servers (a cluster) becomes complex. This is where container orchestration comes in: Deployment Automation: Automates the process of getting your application containers running on a cluster. Scaling: Automatically adjusts the number of container instances based on demand, ensuring performance and availability. Self-Healing: Automatically restarts failed containers, replaces unhealthy ones, and reschedules containers on healthy nodes. Load Balancing: Distributes incoming traffic across multiple container instances to ensure even load. Resource Management: Efficiently allocates compute resources (CPU, memory) to containers across the cluster. Service Discovery: Allows containers to find and communicate with each other easily. Configuration Management: Manages application configurations and sensitive data securely.","title":"Purpose of Container Orchestration"},{"location":"k8s/k8s/#comparison-docker-vs-kubernetes","text":"It's a common misconception that Docker and Kubernetes are competing technologies. In reality, they often complement each other. Feature Docker (Engine/CLI) Kubernetes Primary Role Containerization platform (build, run, share containers) Container Orchestration (manage, scale, deploy containers) Scope Single host (primarily) Cluster of hosts (distributed systems) Focus Packaging applications into portable units Managing the lifecycle of many containers at scale Deployment docker run on a single machine Automated deployment across a cluster Scaling Manual scaling (e.g., docker run multiple times) Automatic scaling based on policies Self-Healing Limited (e.g., restart policy) Robust (restarts, reschedules, replaces failed containers) Networking Basic networking for containers on a single host Advanced networking for inter-container communication across cluster Load Balancing Manual or requires external tools Built-in load balancing and service discovery Configuration Environment variables, bind mounts ConfigMaps, Secrets, Volumes Complexity Relatively simple for single-container apps Higher initial learning curve, powerful for complex apps Typical Usage Local development, running single services Production deployments of microservices, distributed apps","title":"Comparison: Docker vs Kubernetes"},{"location":"k8s/k8s/#analogy","text":"If Docker is the engine for your car (application), then Kubernetes is the traffic management system that ensures all cars on the road (applications) reach their destination efficiently and safely.","title":"\ud83e\udde0 Analogy:"},{"location":"k8s/k8s/#2-kubernetes-architecture","text":"Kubernetes operates on a master-worker architecture. A Kubernetes cluster consists of at least one Master Node and multiple Worker Nodes. Diagram:","title":"2. Kubernetes Architecture"},{"location":"k8s/k8s/#master-node-components","text":"The Master Node (also called Control Plane ) manages the cluster and ensures that it remains in the desired state. It includes the following components:","title":"Master Node Components"},{"location":"k8s/k8s/#kube-apiserver","text":"Purpose : The front-end for the Kubernetes control plane. All communication with the cluster (from kubectl or other components) goes through the API server. Role : Exposes the Kubernetes API, handles REST operations, validates requests, and updates etcd . Interaction : It's the only component that directly talks to etcd .","title":"kube-apiserver"},{"location":"k8s/k8s/#etcd","text":"Purpose : A consistent and highly available key-value store that holds all cluster data (cluster state, configuration, metadata). Role : The single source of truth for the Kubernetes cluster. Interaction : Only the kube-apiserver accesses etcd .","title":"etcd"},{"location":"k8s/k8s/#kube-scheduler","text":"Purpose : Watches for newly created Pods that do not have an assigned node and selects a node for them to run on. Role : Considers resource requirements, hardware/software/policy constraints, affinity/anti-affinity rules, and data locality.","title":"kube-scheduler"},{"location":"k8s/k8s/#kube-controller-manager","text":"Purpose : Runs controller processes. Controllers are control loops that watch the shared state of the cluster via the API server and make changes to drive the current state towards the desired state. Role : Manages various controllers: Node Controller : Detects and responds when nodes go down. Replication Controller : Ensures the correct number of Pods are maintained for each ReplicaSet or ReplicationController. Endpoints Controller : Populates the Endpoints object (connecting Services and Pods). Service Account & Token Controllers : Creates default service accounts and API access tokens for new namespaces.","title":"kube-controller-manager"},{"location":"k8s/k8s/#worker-node-components","text":"Worker Nodes (also called Minions or just Nodes ) run the actual containerized applications.","title":"Worker Node Components"},{"location":"k8s/k8s/#kubelet","text":"Purpose : An agent that runs on","title":"Kubelet"},{"location":"k8s/k8s/#3-kubernetes-core-concepts","text":"Understanding these fundamental building blocks is crucial for working with Kubernetes.","title":"3. Kubernetes Core Concepts"},{"location":"k8s/k8s/#pod","text":"Definition : The smallest deployable unit in Kubernetes. A Pod represents a single instance of a running process in your cluster.","title":"Pod"},{"location":"k8s/k8s/#characteristics","text":"Atomic Unit : Can contain one or more tightly coupled containers that share the same network namespace, IP address, and storage. Ephemeral : Pods are designed to be short-lived. If a Pod dies, Kubernetes creates a new one. Shared Resources : Containers share localhost, networking stack (IP, ports), and volumes. Analogy : A Pod is like a small logical machine that hosts your app\u2019s components. When to use multiple containers in a Pod? Use for sidecar containers (e.g., logging agent, data syncer, proxy) that support the main container.","title":"Characteristics:"},{"location":"k8s/k8s/#replicaset","text":"Definition : Ensures a specified number of Pod replicas are running at all times. Purpose : Maintains availability and scaling. Replaces failed Pods, removes excess. Usage : Typically managed through Deployments , not directly created.","title":"ReplicaSet"},{"location":"k8s/k8s/#deployment","text":"Definition : A higher-level abstraction for managing ReplicaSets and Pods declaratively. Purpose : Manages the desired state (e.g., number of replicas, Pod version).","title":"Deployment"},{"location":"k8s/k8s/#key-features","text":"Rolling Updates : Update with zero downtime. Rollbacks : Revert to previous versions if needed. Scaling : Scale the number of replicas up or down. Analogy : Deployment is like a project manager for your app, ensuring correct versioning and scaling.","title":"Key Features:"},{"location":"k8s/k8s/#service","text":"Definition : An abstraction that exposes a set of Pods as a network service. Purpose : Provides a stable IP/DNS name and acts as a load balancer.","title":"Service"},{"location":"k8s/k8s/#types-of-services","text":"ClusterIP (default) Internal-only access. Use for backend/internal services. NodePort Exposes service on each node\u2019s static port. Access via NodeIP:NodePort . Use for testing/dev environments. LoadBalancer Externally accessible via a cloud load balancer (e.g., AWS ELB). Use for production-grade public apps. ExternalName Maps service to an external DNS name (e.g., my.db.example.com ). No proxying \u2014 returns a CNAME record. Analogy : A Service is like a stable phone number \u2014 callers reach your app even if Pods change.","title":"Types of Services:"},{"location":"k8s/k8s/#namespace","text":"Definition : Provides a scope for resource names. Useful for isolating resources between teams or environments. Purpose : Logical partitioning of resources.","title":"Namespace"},{"location":"k8s/k8s/#default-namespaces","text":"default : For general workloads. kube-system : Kubernetes system resources. kube-public : Public resources. kube-node-lease : Node heartbeat tracking. Best Practice : Use separate Namespaces for dev, staging, production, and teams.","title":"Default Namespaces:"},{"location":"k8s/k8s/#configmap-secret","text":"","title":"ConfigMap &amp; Secret"},{"location":"k8s/k8s/#configmap","text":"Definition : Stores non-confidential config data as key-value pairs. Purpose : Decouple configuration from code. Usage : As environment variables, command args, or mounted files.","title":"ConfigMap:"},{"location":"k8s/k8s/#secret","text":"Definition : Stores sensitive data like passwords, tokens, keys. Purpose : Securely handle confidential information. Security : Base64 encoded by default. Enable encryption for production. Usage : Similar to ConfigMaps, but for secret data. Best Practice : Never store secrets in ConfigMaps.","title":"Secret:"},{"location":"k8s/k8s/#volume-persistentvolumeclaim-pvc","text":"","title":"Volume &amp; PersistentVolumeClaim (PVC)"},{"location":"k8s/k8s/#volume","text":"Definition : A directory accessible to containers in a Pod. Purpose : Shares data between containers or persists data beyond container lifespan.","title":"Volume:"},{"location":"k8s/k8s/#basic-volume-types","text":"emptyDir : Temporary storage, tied to Pod life. hostPath : Mounts node\u2019s file path (not recommended in production).","title":"Basic Volume Types:"},{"location":"k8s/k8s/#persistentvolume-pv","text":"Definition : Pre-provisioned storage in the cluster. Purpose : Durable, cluster-level storage.","title":"PersistentVolume (PV):"},{"location":"k8s/k8s/#persistentvolumeclaim-pvc","text":"Definition : User request for PV. Purpose : Abstracts storage request from underlying storage. Analogy : PV is like a raw hard drive, PVC is the user\u2019s storage request, and Volume is the Pod\u2019s access point.","title":"PersistentVolumeClaim (PVC):"},{"location":"k8s/k8s/#other-workload-resources","text":"","title":"Other Workload Resources"},{"location":"k8s/k8s/#daemonset","text":"Purpose : Ensures a Pod runs on all (or some) nodes. Use Case : Cluster-wide agents (e.g., log collectors, metrics exporters).","title":"DaemonSet"},{"location":"k8s/k8s/#statefulset","text":"Purpose : Manages stateful applications. Use Case : Databases (e.g., MySQL, Kafka) needing stable identities and storage.","title":"StatefulSet"},{"location":"k8s/k8s/#job","text":"Purpose : Creates Pods that run to completion. Use Case : One-off or batch tasks (e.g., report generation).","title":"Job"},{"location":"k8s/k8s/#cronjob","text":"Purpose : Runs Jobs on a schedule (like Unix cron). Use Case : Periodic backups, scheduled reports.","title":"CronJob"},{"location":"k8s/k8s/#4-kubernetes-objects-and-yaml-syntax","text":"Kubernetes resources are defined using YAML ( YAML Ain't Markup Language ) files. These files describe the desired state of objects in your cluster.","title":"4. Kubernetes Objects and YAML Syntax"},{"location":"k8s/k8s/#anatomy-of-a-kubernetes-manifest","text":"Every Kubernetes YAML manifest generally contains four top-level fields :","title":"Anatomy of a Kubernetes Manifest"},{"location":"k8s/k8s/#1-apiversion","text":"What it is : Specifies which version of the Kubernetes API you're using. Examples : v1 (for core resources like Pod, Service) apps/v1 (for Deployments, StatefulSets) batch/v1 (for Jobs, CronJobs)","title":"1. apiVersion"},{"location":"k8s/k8s/#2-kind","text":"What it is : The type of Kubernetes object being created. Examples : Pod , Deployment , Service , ConfigMap , PersistentVolumeClaim","title":"2. kind"},{"location":"k8s/k8s/#3-metadata","text":"What it contains : name : Unique name of the object within a Namespace. namespace : (Optional) Scope of the resource. Defaults to default if not specified. labels : Key-value pairs used for organization and selection. annotations : Additional metadata (non-identifying, like build version or tool info).","title":"3. metadata"},{"location":"k8s/k8s/#4-spec","text":"What it is : Defines the desired state of the object. Note : The structure under spec depends on the object's kind .","title":"4. spec"},{"location":"k8s/k8s/#example-basic-yaml-structure","text":"apiVersion: <api-version> kind: <kind-of-object> metadata: name: <object-name> namespace: <optional-namespace> labels: app: <application-name> tier: <tier-name> spec: # Desired state of the object (varies by kind)","title":"Example Basic YAML Structure"},{"location":"k8s/k8s/#example-yaml-files","text":"These YAML files define various Kubernetes resources like Pods, Deployments, Services, ConfigMaps, and PVCs.","title":"Example YAML Files"},{"location":"k8s/k8s/#pod-example","text":"# my-pod.yaml apiVersion: v1 kind: Pod metadata: name: my-nginx-pod labels: app: web tier: frontend spec: containers: - name: nginx-container image: nginx:latest ports: - containerPort: 80 Deployment Example # my-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: my-web-deployment labels: app: web spec: replicas: 3 # Desired number of Pod replicas selector: matchLabels: app: web # Selects Pods with label app: web template: # Pod template metadata: labels: app: web version: v1.0.0 spec: containers: - name: nginx-container image: nginx:1.21.6 ports: - containerPort: 80 resources: # Optional: Define resource requests and limits requests: memory: \"64Mi\" cpu: \"250m\" # 0.25 CPU core limits: memory: \"128Mi\" cpu: \"500m\" # 0.5 CPU core Service Example (NodePort) # my-service.yaml apiVersion: v1 kind: Service metadata: name: my-web-service labels: app: web spec: selector: app: web # Selects Pods with label app: web type: NodePort # Exposes service on a static port on each node ports: - protocol: TCP port: 80 # Service port (internal) targetPort: 80 # Container port nodePort: 30007 # Optional: Specific node port (range 30000-32767) ConfigMap Example # my-configmap.yaml apiVersion: v1 kind: ConfigMap metadata: name: app-config data: # Key-value pairs for configuration APP_COLOR: blue APP_ENV: development database.url: jdbc:mysql://localhost:3306/mydb PersistentVolumeClaim (PVC) Example # my-pvc.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: my-data-pvc spec: accessModes: - ReadWriteOnce # Can be mounted as read-write by a single node resources: requests: storage: 5Gi # Request 5 Gigabytes of storage # storageClassName: standard # Optional: If you have a specific StorageClass","title":"\ud83e\uddf1 Pod Example"},{"location":"k8s/k8s/#5-kubernetes-cli-kubectl","text":"kubectl is the command-line tool for interacting with Kubernetes clusters.","title":"5. Kubernetes CLI (kubectl)"},{"location":"k8s/k8s/#cluster-interaction","text":"kubectl communicates with the kube-apiserver on the Control Plane (Master Node).","title":"\ud83d\udd0c Cluster Interaction"},{"location":"k8s/k8s/#common-kubectl-commands-grouped-by-function","text":"","title":"\ud83d\udee0\ufe0f Common kubectl Commands (Grouped by Function)"},{"location":"k8s/k8s/#creation-application","text":"Apply a configuration (create or update): kubectl apply -f <filename.yaml> kubectl apply -f <directory_containing_yamls>/ # Example: kubectl apply -f my-deployment.yaml Best Practice: Always use kubectl apply for managing resources, as it's idempotent (can be run multiple times safely). Create a resource (if it doesn't exist): kubectl create -f <filename.yaml> # Creates only if resource doesn't exist kubectl create deployment my-app --image=nginx # Quick imperitive command Note: kubectl create is generally used for initial setup or one-off resources . kubectl apply is preferred for declarative, version-controlled resource management .","title":"\u2705 Creation &amp; Application"},{"location":"k8s/k8s/#getting-information","text":"","title":"\ud83d\udd0d Getting Information"},{"location":"k8s/k8s/#list-resources","text":"kubectl get pods kubectl get deployments kubectl get services kubectl get all # Get common resources (pods, services, deployments, replicasets) kubectl get pods -o wide # Show more details (Node IP, Pod IP) kubectl get pods -n <namespace> # Get pods in a specific namespace kubectl get pods --show-labels # Show labels","title":"List resources:"},{"location":"k8s/k8s/#describe-a-resource-detailed-information","text":"kubectl describe pod <pod-name> kubectl describe deployment <deployment-name> kubectl describe service <service-name> # Example: kubectl describe pod my-nginx-pod-abc12 Purpose: Shows events, status, resource limits, volumes, etc. Indispensable for troubleshooting.","title":"Describe a resource (detailed information):"},{"location":"k8s/k8s/#view-logs-from-a-container-in-a-pod","text":"kubectl logs <pod-name> kubectl logs -f <pod-name> # Follow logs in real-time kubectl logs <pod-name> -c <container-name> # For multi-container pods","title":"View logs from a container in a Pod:"},{"location":"k8s/k8s/#execute-a-command-in-a-running-container","text":"kubectl exec -it <pod-name> -- /bin/bash # Get a shell into the container kubectl exec <pod-name> -- ls /app # Run a command # Example: kubectl exec -it my-nginx-pod-abc12 -- bash","title":"Execute a command in a running container:"},{"location":"k8s/k8s/#copy-files-tofrom-a-container","text":"kubectl cp <source-path> <pod-name>:<destination-path> kubectl cp <pod-name>:<source-path> <destination-path> # Example: kubectl cp my-local-file.txt my-nginx-pod-abc12:/usr/share/nginx/html/","title":"Copy files to/from a container:"},{"location":"k8s/k8s/#view-resource-usage-requires-metrics-server","text":"kubectl top nodes kubectl top pods","title":"View resource usage (requires Metrics Server):"},{"location":"k8s/k8s/#check-cluster-events","text":"kubectl get events","title":"Check cluster events:"},{"location":"k8s/k8s/#deletion","text":"Delete a resource: kubectl delete -f <filename.yaml> kubectl delete pod <pod-name> kubectl delete deployment <deployment-name> kubectl delete service <service-name> kubectl delete namespace <namespace-name> # Deletes everything in that namespace # Example: kubectl delete -f my-deployment.yaml kubectl delete deployment my-web-deployment","title":"Deletion:"},{"location":"k8s/k8s/#scaling-and-updates","text":"Scale a Deployment: kubectl scale deployment <deployment-name> --replicas=<number> # Example: kubectl scale deployment my-web-deployment --replicas=5 Rollout status/history/undo: kubectl rollout status deployment/<deployment-name> kubectl rollout history deployment/<deployment-name> kubectl rollout undo deployment/<deployment-name> # Rollback to previous version","title":"Scaling and Updates:"},{"location":"k8s/k8s/#namespace-management","text":"List namespaces: kubectl get namespaces Create a namespace: kubectl create namespace <namespace-name> # Example: kubectl create namespace dev-env Set default namespace for current context: kubectl config set-context --current --namespace=<namespace-name> # Example: kubectl config set-context --current --namespace=dev-env This makes your infrastructure version-controllable and repeatable.","title":"Namespace Management:"},{"location":"k8s/k8s/#best-practices-for-kubectl","text":"Declarative vs. Imperative : While imperative commands ( kubectl run , kubectl create deployment ) are useful for quick tests, prefer declarative management using YAML files with: kubectl apply -f <file.yaml> This makes your infrastructure version-controllable and repeatable.","title":"Best Practices for kubectl"},{"location":"k8s/k8s/#namespaces","text":"Always specify the namespace using the -n <namespace> flag if you're not operating in the default namespace. bash kubectl get pods -n dev","title":"\ud83d\udcdb Namespaces"},{"location":"k8s/k8s/#labels","text":"Use labels extensively for organizing and selecting Kubernetes resources. Labels are key-value pairs used to categorize resources. They enable filtering, selection, and grouping for operations like deployments, services, and monitoring. Example (YAML): metadata: labels: app: my-app environment: dev","title":"\ud83c\udff7\ufe0f Labels"},{"location":"k8s/k8s/#describe-for-troubleshooting","text":"When something isn't working, kubectl describe should be your first stop . It provides detailed insights into the resource's current state. Useful information includes: Events and warnings Pod scheduling and status Liveness/readiness probe results Volume mounts and conditions Example: kubectl describe pod my-app-pod","title":"\ud83d\udee0\ufe0f Describe for Troubleshooting"},{"location":"k8s/k8s/#logs-for-application-insights","text":"Use kubectl logs to check logs and understand application behavior . Examples: kubectl logs <pod-name> kubectl logs -f <pod-name> # Follow logs in real time kubectl logs <pod-name> -c <container> # For multi-container Pods","title":"\ud83d\udcc4 Logs for Application Insights"},{"location":"k8s/k8s/#6-kubernetes-networking","text":"Kubernetes networking enables communication between Pods, Services, and the outside world. It's a complex topic, but here's a simplified overview.","title":"6. Kubernetes Networking"},{"location":"k8s/k8s/#key-principles","text":"Every Pod gets its own unique IP address. Pods on a node can communicate with all Pods on all other nodes without NAT. Agents on a node (e.g., kubelet) can communicate with all Pods on that node.","title":"Key Principles:"},{"location":"k8s/k8s/#pod-to-pod-communication","text":"When Pods are on the same Node : They communicate directly using their Pod IP addresses. When Pods are on different Nodes : Traffic is routed between nodes by the underlying Container Network Interface (CNI) plugin (e.g., Calico, Flannel, Weave Net). Each Pod has a unique IP address within the cluster, and these IPs are routable across the cluster.","title":"Pod-to-Pod Communication"},{"location":"k8s/k8s/#service-to-service-communication","text":"Services provide a stable IP address and DNS name for a set of Pods. Pods communicate with each other via Services using the Service's stable IP address or DNS name. kube-proxy on each node ensures that traffic sent to a Service's IP is correctly load-balanced to the healthy Pods backing that Service. Example : A frontend Pod wants to talk to a backend Pod. Instead of knowing the backend Pod's ephemeral IP, it sends traffic to the backend-service name or IP, and Kubernetes handles the routing and load balancing.","title":"Service-to-Service Communication"},{"location":"k8s/k8s/#dns-resolution","text":"Kubernetes provides internal DNS resolution. Services are automatically assigned DNS names. Within the same Namespace : service-name Across Namespaces : service-name.namespace-name.svc.cluster.local This allows Pods to discover and communicate with Services by name rather than by IP address.","title":"DNS Resolution"},{"location":"k8s/k8s/#network-policies-basic-intro","text":"Definition : Kubernetes Network Policies specify how groups of Pods are allowed to communicate with each other and with external network endpoints. Purpose : Enhance security by restricting network access between Pods. By default, Pods are non-isolated and can accept traffic from any source. Requirement : Network Policies require a CNI plugin that supports them (e.g., Calico, Cilium). Analogy : Network Policies are like firewall rules for your Pods.","title":"Network Policies (Basic Intro)"},{"location":"k8s/k8s/#7-kubernetes-storage","text":"Kubernetes provides robust mechanisms for managing storage, allowing applications to persist data beyond the life of a single container or Pod.","title":"7. Kubernetes Storage"},{"location":"k8s/k8s/#types-of-volumes","text":"Kubernetes Volumes are directories accessible to the containers in a Pod. The data in a Volume persists as long as the Pod exists. Some common types:","title":"Types of Volumes"},{"location":"k8s/k8s/#emptydir","text":"Purpose : A simple, empty volume created when a Pod is first assigned to a node. Persistence : Its contents are deleted when the Pod is removed from the node. Use Case : Temporary scratch space, sharing files between containers in the same Pod.","title":"emptyDir:"},{"location":"k8s/k8s/#hostpath","text":"Purpose : Mounts a file or directory from the host node's filesystem into a Pod. Persistence : Data persists beyond Pod lifecycle, but tied to a specific node. Use Case : Primarily for system-level Pods (e.g., monitoring agents), or if you need access to host files. Caution : Generally discouraged for production applications due to lack of portability and potential security risks.","title":"hostPath:"},{"location":"k8s/k8s/#persistentvolume-pv-and-persistentvolumeclaim-pvc-covered-in-section-3","text":"PV : A piece of storage in the cluster, provisioned by an admin (or dynamically). PVC : A request for storage by a user, that binds to an available PV. Purpose : Provides a way to consume durable storage abstractly. Use Case : Databases, persistent application data.","title":"persistentVolume (PV) and persistentVolumeClaim (PVC): (Covered in Section 3)"},{"location":"k8s/k8s/#storageclasses-basic-overview","text":"Definition : An API object that describes the \"classes\" of storage offered in a cluster. Purpose : Allows administrators to define different types of storage (e.g., \"fast-SSD\", \"cheap-HDD\", \"network-storage\") and users to request them without knowing the underlying storage details. Dynamic Provisioning : When a PVC requests a storageClassName , the StorageClass can dynamically provision a matching PV for that PVC. Analogy : StorageClass is like a catalog of storage options, and PVC is like ordering from that catalog.","title":"StorageClasses (Basic Overview)"},{"location":"k8s/k8s/#8-kubernetes-services-comparison-table","text":"Here's a comparison of the main Service types in Kubernetes, including Ingress for external access. Feature ClusterIP NodePort LoadBalancer Ingress Exposure Internal to cluster On each Node's IP at a static port External IP provisioned by cloud provider HTTP/HTTPS routing based on host/path Accessibility Only from within the cluster From outside the cluster (via NodeIP:NodePort) From anywhere on the internet From anywhere on the internet (via DNS of Ingress controller) Load Balancing Internal ( kube-proxy ) Internal ( kube-proxy ) External (cloud provider's LB) Application-layer (L7) (Ingress controller) Cost Free Free Varies by cloud provider (often charged) Requires Ingress Controller (potentially charged for underlying LB) Complexity Low Low Moderate (requires cloud provider setup) Moderate to High (requires Ingress Controller setup) Use Cases Internal microservices, backend services Demo/testing, non-production apps, exposing a few services Production apps in cloud, public APIs Production web apps (HTTP/HTTPS), multiple services on single IP, SSL termination DNS Internal DNS name Internal DNS name + NodeIP/NodePort External IP + Internal DNS name External DNS name (for Ingress Host)","title":"8. Kubernetes Services Comparison Table"},{"location":"k8s/k8s/#9-kubernetes-ingress","text":"While Services expose applications, Ingress is designed for managing external access to services in a cluster, typically HTTP and HTTPS.","title":"9. Kubernetes Ingress"},{"location":"k8s/k8s/#ingress-controller-and-ingress-resource","text":"","title":"Ingress Controller and Ingress Resource"},{"location":"k8s/k8s/#ingress-controller","text":"Definition : An application that runs in your cluster and watches the Kubernetes API for Ingress resources. Purpose : Fulfills the Ingress rules by acting as a reverse proxy/load balancer. Common Ingress Controllers include Nginx Ingress Controller, Traefik, Istio, GKE Ingress, AWS ALB Ingress Controller. Deployment : The Ingress Controller itself is typically deployed as a Deployment and exposed via a NodePort or LoadBalancer Service.","title":"Ingress Controller:"},{"location":"k8s/k8s/#ingress-resource","text":"Definition : A Kubernetes API object that defines rules for routing external HTTP/HTTPS traffic to Services within the cluster. Purpose : Provides flexible routing based on hostname, path, and TLS termination. Analogy : The Ingress Controller is the actual traffic cop, and the Ingress Resource is the rulebook that tells the traffic cop how to direct traffic. Ingress Architecture:","title":"Ingress Resource:"},{"location":"k8s/k8s/#basic-ingress-yaml-example","text":"This example routes traffic for myapp.example.com/api to api-service and myapp.example.com/ to frontend-service . #### my-ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-app-ingress annotations: # Example annotation for Nginx Ingress Controller: nginx.ingress.kubernetes.io/rewrite-target: / spec: rules: - host: myapp.example.com http: paths: - path: /api pathType: Prefix backend: service: name: api-service # Name of your API Service port: number: 8080 - path: / pathType: Prefix backend: service: name: frontend-service # Name of your Frontend Service port: number: 80 # Optional: TLS/SSL termination # tls: # - hosts: # - myapp.example.com # secretName: my-app-tls-secret # Secret containing TLS certificate and key Note: You must have an Ingress Controller running in your cluster for Ingress resources to work.","title":"Basic Ingress YAML Example"},{"location":"k8s/k8s/#10-helm-basics","text":"Helm is a package manager for Kubernetes. It simplifies the deployment and management of applications on Kubernetes clusters.","title":"10. Helm Basics"},{"location":"k8s/k8s/#what-is-helm","text":"Definition : The \"apt/yum/brew\" for Kubernetes. Purpose : Helps you define, install, and upgrade even the most complex Kubernetes applications.","title":"What is Helm?"},{"location":"k8s/k8s/#key-concepts","text":"Charts : Pre-configured Kubernetes resource packages. Repositories : Places where charts are stored and shared. Releases : An instance of a chart running in a Kubernetes cluster.","title":"Key Concepts:"},{"location":"k8s/k8s/#helm-charts-and-their-structure","text":"A Helm Chart is a collection of files that describe a related set of Kubernetes resources. Think of it as a template for a Kubernetes application. Typical Chart Structure:","title":"Helm Charts and their Structure"},{"location":"k8s/k8s/#helm-chart-structure-my-app-chart","text":"my-app-chart/ \u251c\u2500\u2500 Chart.yaml # A YAML file containing information about the chart (name, version, etc.) \u251c\u2500\u2500 values.yaml # Default configuration values for the chart \u251c\u2500\u2500 templates/ # Directory containing Kubernetes manifest templates \u2502 \u251c\u2500\u2500 deployment.yaml # Template for a Deployment object \u2502 \u251c\u2500\u2500 service.yaml # Template for a Service object \u2502 \u251c\u2500\u2500 _helpers.tpl # Optional: Contains reusable template snippets \u2502 \u2514\u2500\u2500 NOTES.txt # Optional: Instructions for the user after installation \u251c\u2500\u2500 charts/ # Optional: Contains dependent charts (subcharts) \u2514\u2500\u2500 README.md # Optional: A brief description of the chart Installing and Using Helm Commands Install Helm CLI: macOS (Homebrew): brew install helm Linux: Download from helm.sh or use package manager. Add a Chart Repository (e.g., Bitnami stable charts): helm repo add bitnami https://charts.bitnami.com/bitnami helm repo update # Update information about charts from all repositories Search for Charts: helm search repo nginx Install a Chart: helm install <release-name> <chart-name> --namespace <namespace> --values <your-values.yaml> # Example: Install Nginx Ingress Controller helm install my-nginx-ingress bitnami/nginx-ingress-controller --namespace ingress-nginx # Example: Install WordPress helm install my-wordpress bitnami/wordpress --set mysql.rootPassword=mysecretpassword --namespace blog --set: Override specific values from values.yaml directly on the command line. --values: Provide an entire custom values.yaml file. List Releases: helm list helm list -n <namespace> Upgrade a Release: helm upgrade <release-name> <chart-name> --namespace <namespace> --values <your-new-values.yaml> # Example: helm upgrade my-wordpress bitnami/wordpress -f my-new-wordpress-values.yaml Uninstall a Release: helm uninstall <release-name> --namespace <namespace> # Example: helm uninstall my-wordpress -n blog Get Release Status: helm status <release-name> -n <namespace> Lint a Chart (check for best practices and syntax errors): helm lint ./my-app-chart Package a Chart: helm package ./my-app-chart","title":"Helm Chart Structure: my-app-chart/"},{"location":"k8s/k8s/#11-kubernetes-security-basics","text":"Security is paramount in Kubernetes. Here are fundamental concepts. Role-Based Access Control (RBAC) Purpose: Authorizes users and applications to interact with the Kubernetes API. Concepts: Role: Defines a set of permissions within a specific Namespace (e.g., \"can read Pods\" or \"can manage Deployments\"). ClusterRole: Similar to a Role, but applies across the entire cluster (non-namespaced resources like Nodes or PersistentVolumes, or namespaced resources across all Namespaces). RoleBinding: Grants the permissions defined in a Role to a user, group, or ServiceAccount within a specific Namespace. ClusterRoleBinding: Grants the permissions defined in a ClusterRole to a user, group, or ServiceAccount across the entire cluster. Analogy: RBAC is like defining roles in an organization (e.g., \"Manager,\" \"Developer\") and then assigning those roles to specific people or teams. ServiceAccount Definition: Provides an identity for processes that run in a Pod. Purpose: Allows Pods to authenticate to the Kubernetes API server when they need to perform actions (e.g., a controller that watches for new resources). Default: Every Pod automatically gets a default ServiceAccount in its Namespace, which usually has limited permissions. Best Practice: Create specific ServiceAccounts with the minimal necessary permissions for your applications. Network Policies Purpose: (As discussed in Section 6) Control Pod-to-Pod communication using firewall rules. By default, Pods are open. Network Policies allow you to isolate them. Best Practice: Implement Network Policies to restrict traffic flows to only what is necessary, following the principle of least privilege. Secrets and ConfigMaps (Best Practices) Secrets: (As discussed in Section 3) For sensitive data. Best Practice: Always use Secrets for credentials. Do not store sensitive data in ConfigMaps or directly in YAML files in version control. For production, consider external Secret management solutions (e.g., HashiCorp Vault, cloud provider KMS integrations) to avoid storing plaintext secrets in etcd or in your Kubernetes manifests. ConfigMaps: For non-confidential configuration. Best Practice: Use ConfigMaps to decouple configuration from your application images.","title":"11. Kubernetes Security Basics"},{"location":"k8s/k8s/#12-monitoring-and-logging","text":"Effective monitoring and logging are crucial for understanding the health and performance of your Kubernetes applications and cluster. Basic Health Checks - Liveness Probes : (See Section 14) Determine if a container is running and healthy. If a Liveness Probe fails, Kubernetes restarts the container. Readiness Probes : (See Section 14) Determine if a container is ready to serve traffic. If a Readiness Probe fails, the Pod is removed from Service load balancing until it becomes ready. kubectl logs and kubectl top - kubectl logs : (As discussed in Section 5) Retrieve standard output and standard error from containers. Essential for debugging application issues. kubectl top : (As discussed in Section 5) Provides basic CPU and memory usage of nodes and pods. Requires the Kubernetes Metrics Server to be installed in the cluster. Prometheus and Grafana Overview These are de-facto standards for monitoring in Kubernetes environments. Prometheus : Purpose : A powerful open-source monitoring and alerting toolkit designed for reliability and scalability. How it works : Scrapes metrics from configured targets (Kubernetes components, application endpoints) at regular intervals, stores them, and allows for querying and alerting. Grafana : Purpose : An open-source analytics and interactive visualization web application. How it works : Used to create dashboards that visualize data collected by Prometheus (or other data sources). Provides powerful querying and visualization capabilities. Typical Setup: Prometheus Server (runs in Kubernetes) scrapes metrics. Grafana (runs in Kubernetes) connects to Prometheus as a data source and displays dashboards. Node Exporter (DaemonSet) on each node exposes node-level metrics for Prometheus. kube-state-metrics (Deployment) exposes Kubernetes object metrics (e.g., Pod status, Deployment replicas).","title":"12. Monitoring and Logging"},{"location":"k8s/k8s/#13-deploying-a-full-stack-app-spring-boot-angular-mysql","text":"","title":"13. Deploying a Full-Stack App (Spring Boot + Angular + MySQL)"},{"location":"k8s/k8s/#full-stack-application-architecture","text":"","title":"Full-Stack Application Architecture"},{"location":"k8s/k8s/#application-components","text":"Frontend : Angular application served by Nginx Backend : Spring Boot REST API Database : MySQL","title":"Application Components"},{"location":"k8s/k8s/#kubernetes-application-architecture","text":"User | V +---------------------+ | Internet / Browser | +---------------------+ | (HTTP/HTTPS) V +---------------------+ | Ingress Controller | +---------------------+ | |--> Host: `myapp.com/api` \u2192 Spring Boot Service |--> Host: `myapp.com/` \u2192 Angular Service V +-----------------------------------+ | Kubernetes Cluster | | | | +---------------------------+ | | | Frontend Service | | | | (ClusterIP) | | | +----+----------------------+ | | | | | V | | +---------------------------+ | | | Frontend Deployment | | | | (Nginx + Angular) | | | +---------------------------+ | | | | +---------------------------+ | | | Backend Service | | | | (ClusterIP) | | | +----+----------------------+ | | | | | V | | +---------------------------+ | | | Backend Deployment | | | | (Spring Boot) | | | +----+----------------------+ | | | | | V | | +---------------------------+ | | | MySQL Service | | | | (ClusterIP) | | | +----+----------------------+ | | | | | V | | +---------------------------+ | | | MySQL StatefulSet | | | | + PVC for Data | | | +---------------------------+ | +-----------------------------------+ YAML Manifests: We'll use a single k8s-fullstack.yaml file for simplicity.","title":"Kubernetes Application Architecture"},{"location":"k8s/k8s/#k8s-fullstackyaml","text":"","title":"k8s-fullstack.yaml"},{"location":"k8s/k8s/#1-mysql-deployment-using-statefulset-for-persistence","text":"apiVersion: apps/v1 kind: StatefulSet metadata: name: mysql labels: app: mysql spec: selector: matchLabels: app: mysql serviceName: \"mysql\" # headless service for stable network identity replicas: 1 template: metadata: labels: app: mysql spec: containers: - name: mysql image: mysql:8.0 env: - name: MYSQL_ROOT_PASSWORD valueFrom: secretKeyRef: name: mysql-secret key: mysql-root-password - name: MYSQL_DATABASE valueFrom: configMapKeyRef: name: app-config key: MYSQL_DATABASE ports: - containerPort: 3306 name: mysql volumeMounts: - name: mysql-data # Mount the volume for persistent data mountPath: /var/lib/mysql volumeClaimTemplates: # Define the PVC for this StatefulSet - metadata: name: mysql-data spec: accessModes: [ \"ReadWriteOnce\" ] resources: requests: storage: 5Gi # Request 5GB of storage # storageClassName: standard # Uncomment if you have a specific StorageClass","title":"1. MySQL Deployment (using StatefulSet for persistence)"},{"location":"k8s/k8s/#2-mysql-service-clusterip-for-internal-communication","text":"apiVersion: v1 kind: Service metadata: name: mysql-service labels: app: mysql spec: ports: - port: 3306 targetPort: 3306 protocol: TCP name: mysql selector: app: mysql clusterIP: None # Headless service for StatefulSet","title":"2. MySQL Service (ClusterIP, for internal communication)"},{"location":"k8s/k8s/#3-spring-boot-backend-deployment","text":"apiVersion: apps/v1 kind: Deployment metadata: name: spring-boot-backend labels: app: backend spec: replicas: 2 selector: matchLabels: app: backend template: metadata: labels: app: backend spec: containers: - name: spring-boot-app image: yourusername/spring-boot-app:1.0.0 # Replace with your image! env: - name: SPRING_DATASOURCE_URL valueFrom: configMapKeyRef: name: app-config key: SPRING_DATASOURCE_URL - name: SPRING_DATASOURCE_USERNAME valueFrom: secretKeyRef: name: mysql-secret key: mysql-username - name: SPRING_DATASOURCE_PASSWORD valueFrom: secretKeyRef: name: mysql-secret key: mysql-password ports: - containerPort: 8080 livenessProbe: # Example liveness probe httpGet: path: /actuator/health/liveness # Adjust path for your Spring Boot app port: 8080 initialDelaySeconds: 30 periodSeconds: 10 readinessProbe: # Example readiness probe httpGet: path: /actuator/health/readiness # Adjust path port: 8080 initialDelaySeconds: 15 periodSeconds: 5","title":"3. Spring Boot Backend Deployment"},{"location":"k8s/k8s/#4-spring-boot-backend-service-clusterip-for-internal-and-ingress-access","text":"apiVersion: v1 kind: Service metadata: name: backend-service labels: app: backend spec: selector: app: backend ports: - protocol: TCP port: 8080 targetPort: 8080 type: ClusterIP","title":"4. Spring Boot Backend Service (ClusterIP, for internal and Ingress access)"},{"location":"k8s/k8s/#5-angular-frontend-deployment","text":"apiVersion: apps/v1 kind: Deployment metadata: name: angular-frontend labels: app: frontend spec: replicas: 2 selector: matchLabels: app: frontend template: metadata: labels: app: frontend spec: containers: - name: nginx-angular image: yourusername/angular-nginx:1.0.0 # Replace with your image! ports: - containerPort: 80","title":"5. Angular Frontend Deployment"},{"location":"k8s/k8s/#6-angular-frontend-service-clusterip-for-ingress-access","text":"apiVersion: v1 kind: Service metadata: name: frontend-service labels: app: frontend spec: selector: app: frontend ports: - protocol: TCP port: 80 targetPort: 80 type: ClusterIP","title":"6. Angular Frontend Service (ClusterIP, for Ingress access)"},{"location":"k8s/k8s/#7-configmap-for-application-configuration","text":"apiVersion: v1 kind: ConfigMap metadata: name: app-config data: MYSQL_DATABASE: myappdb SPRING_DATASOURCE_URL: jdbc:mysql://mysql-service:3306/myappdb?useSSL=false&allowPublicKeyRetrieval=true","title":"7. ConfigMap for application configuration"},{"location":"k8s/k8s/#8-secret-for-sensitive-data-base64-encoded","text":"# Create secrets first: # echo -n 'root_password_here' | base64 # echo -n 'myuser' | base64 # echo -n 'mypassword' | base64 apiVersion: v1 kind: Secret metadata: name: mysql-secret type: Opaque data: mysql-root-password: <base64_encoded_root_password> # e.g., cG9zdGdyZXNfcGFzc3dvcmRfaGVyZQ== mysql-username: <base64_encoded_db_username> mysql-password: <base64_encoded_db_password>","title":"8. Secret for sensitive data (base64 encoded)"},{"location":"k8s/k8s/#9-ingress-for-external-routing","text":"apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-app-ingress annotations: # Use appropriate annotations for your Ingress Controller (e.g., Nginx, AWS ALB) # For Nginx Ingress Controller: nginx.ingress.kubernetes.io/rewrite-target: /$2 # For path stripping if needed nginx.ingress.kubernetes.io/ssl-redirect: \"false\" # Optional, if not using HTTPS spec: ingressClassName: nginx # Required for Kubernetes v1.18+ rules: - host: myapp.example.com # Replace with your domain http: paths: - path: /api(/|$)(.*) # Route traffic for /api to backend pathType: Prefix backend: service: name: backend-service port: number: 8080 - path: /(.*) # Route all other traffic to frontend pathType: Prefix backend: service: name: frontend-service port: number: 80 # Uncomment and configure TLS if you have a certificate secret # tls: # - hosts: # - myapp.example.com # secretName: myapp-tls-secret # Create this secret with 'kubectl create secret tls myapp-tls-secret --key private.key --cert certificate.crt' Deployment Steps: Build and push your Docker images: docker build -t yourusername/spring-boot-app:1.0.0 ./spring-boot-app docker push yourusername/spring-boot-app:1.0.0 docker build -t yourusername/angular-nginx:1.0.0 ./angular-nginx docker push yourusername/angular-nginx:1.0.0 Create your mysql-secret: kubectl create secret generic mysql-secret \\ --from-literal=mysql-root-password='your_root_password' \\ --from-literal=mysql-username='myuser' \\ --from-literal=mysql-password='mypassword' Apply the full-stack YAML: kubectl apply -f k8s-fullstack.yaml Verify Deployments and Services: kubectl get deployments kubectl get pods kubectl get services kubectl get pvc kubectl get ingress Access the application: If using a cloud provider, the LoadBalancer for your Ingress Controller will get an external IP. Update your DNS A record for myapp.example.com to point to the Ingress LoadBalancer IP. Alternatively, if using NodePort for Ingress Controller, access via NodeIP:NodePort.","title":"9. Ingress for external routing"},{"location":"k8s/k8s/#14-kubernetes-best-practices","text":"Adopting these practices ensures robust, scalable, and maintainable applications in Kubernetes. Liveness and Readiness Probes Liveness Probe: Purpose: Tells Kubernetes when to restart a container. If the Liveness Probe fails, Kubernetes knows the container is unhealthy and will terminate and restart it. Configuration: httpGet, tcpSocket, or exec command. Example (in Pod/Deployment spec): livenessProbe: httpGet: path: /healthz port: 8080 initialDelaySeconds: 15 # Wait 15s before first check periodSeconds: 10 # Check every 10s timeoutSeconds: 5 # Timeout after 5s failureThreshold: 3 # Restart after 3 failed attempts Readiness Probe: Purpose: Tells Kubernetes when a container is ready to serve traffic. If the Readiness Probe fails, the Pod is removed from the Service's endpoints (no traffic is sent to it) until it becomes ready. Configuration: httpGet, tcpSocket, or exec command. Example (in Pod/Deployment spec): readinessProbe: httpGet: path: /ready port: 8080 initialDelaySeconds: 5 periodSeconds: 5 timeoutSeconds: 3 failureThreshold: 1 # Unready after 1 failed attempt Difference: Liveness deals with \"should I restart this container?\" , Readiness deals with \"is this container ready to accept requests?\". Resource Limits and Requests Purpose: Crucial for efficient resource allocation and cluster stability. requests: The minimum amount of CPU and memory a container needs. Kubernetes uses this for scheduling decisions (ensures a node has enough resources available). limits: The maximum amount of CPU and memory a container can use. If a container exceeds its memory limit, it's terminated. If it exceeds its CPU limit, it's throttled. Example (in container spec): resources: requests: memory: \"256Mi\" cpu: \"500m\" # 0.5 CPU core limits: memory: \"512Mi\" cpu: \"1000m\" # 1 CPU core Best Practice: Always define requests and limits for your production workloads. Separation by Namespaces Purpose: (As discussed in Section 3) Logical isolation within a cluster. Best Practice: Create separate Namespaces for different environments (e.g., dev, staging, prod). Create separate Namespaces for different teams or applications. Facilitates RBAC, Network Policies, and resource quotas. Auto-scaling with Horizontal Pod Autoscaler (HPA) Purpose: Automatically scales the number of Pod replicas in a Deployment or ReplicaSet based on observed CPU utilization or other custom metrics. How it works: HPA continuously monitors metrics and adjusts the replicas field of the target resource. Example: apiVersion: autoscaling/v2 kind: HorizontalPodAutoscaler metadata: name: my-web-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: my-web-deployment # Target Deployment to scale minReplicas: 2 maxReplicas: 10 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 # Target 70% average CPU utilization # - type: Resource # Example for memory # resource: # name: memory # target: # type: AverageValue # averageValue: 200Mi ``` Best Practice: Use HPA to ensure your application can handle varying loads efficiently. Requires the Metrics Server. ## 15. Cleanup and Maintenance Regular cleanup and maintenance are essential for keeping your Kubernetes cluster healthy and cost-efficient. Commands to Delete Resources Delete by file: ```Bash kubectl delete -f <filename.yaml> Delete by type and name: kubectl delete deployment <deployment-name> kubectl delete service <service-name> kubectl delete pod <pod-name> --grace-period=0 --force # Force delete a stuck pod kubectl delete pvc <pvc-name> kubectl delete pv <pv-name> # Careful! Ensure no PVCs are using it. Delete multiple resources by label: kubectl delete pods -l app=nginx Delete all resources of a type in a namespace: kubectl delete all --all -n <namespace> # Deletes all common resources (deployments, services, pods, etc.) Delete a Namespace and all its contents: kubectl delete namespace <namespace-name> Cleaning Up Cluster Resources Pruning unused resources (Disk space): docker system prune -a # On your node if Docker is container runtime, to clean up unused images/containers Note: This is usually done at the Docker daemon level on individual nodes, not directly kubectl. Kubernetes itself manages the lifecycle of its objects. Deleting PersistentVolumes: When you delete a PVC, the corresponding PV might not be automatically deleted. Check the Reclaim Policy of the PV (e.g., Retain, Recycle, Delete). If Retain, you must manually delete the PV after the PVC is gone. kubectl get pv kubectl delete pv <pv-name> Inspecting Pods Check Pod status: kubectl get pods Common statuses: Running, Pending, ContainerCreating, Error, CrashLoopBackOff. Get detailed information for a specific Pod: kubectl describe pod <pod-name> Look at Events section for common issues (e.g., FailedScheduling, ImagePullBackOff, LivenessProbe failed). Check Pod logs: kubectl logs <pod-name>","title":"14. Kubernetes Best Practices"},{"location":"k8s/k8s/#16-comparison-tables","text":"","title":"16. Comparison Tables"},{"location":"k8s/k8s/#docker-compose-vs-kubernetes","text":"Feature Docker Compose Kubernetes Primary Use Local development, single-host multi-container apps Production deployments, large-scale distributed systems Orchestration Basic (starts/stops linked containers) Advanced (auto-scaling, self-healing, rolling updates) Scalability Manual scaling on a single host ( docker-compose up --scale ) Automatic scaling across a cluster High Availability Limited to single host, no automatic failover Built-in HA, automatic failover of workloads Complexity Simpler, faster to set up for small projects Higher learning curve, more powerful and flexible Deployment Unit Service (defined in docker-compose.yml ) Pod (managed by Deployments, StatefulSets, etc.) Networking Bridge networks between services on single host Complex networking across multiple nodes, CNI plugins Storage Docker volumes, bind mounts PV/PVC, StorageClasses, various volume types Security Basic (user/group permissions, Docker security) Robust RBAC, Network Policies, Secrets management Tools docker compose CLI kubectl CLI, Helm, dashboard, cloud provider tools Ideal For Quick local dev, small projects, PoCs Microservices, enterprise-grade applications, cloud-native","title":"Docker Compose vs Kubernetes"},{"location":"k8s/k8s/#replicaset-vs-deployment-vs-statefulset","text":"Feature ReplicaSet Deployment StatefulSet Primary Purpose Ensure desired number of Pod replicas Declarative updates and management of Pods/ReplicaSets Manage stateful applications with stable identity Pod Identity No stable identity (random Pod names) No stable identity (random Pod names) Stable, unique network identifiers (e.g., mysql-0 ) Pod Ordering No guaranteed ordering for creation/deletion No guaranteed ordering for creation/deletion Guaranteed ordered, graceful deployment/deletion Persistent Storage Can use PVCs, but Pod-to-PVC mapping is not stable Can use PVCs, but Pod-to-PVC mapping is not stable Each Pod gets its own dedicated, stable PVC (via volumeClaimTemplates ) Use Case Underlying controller for Deployments Stateless applications, web servers, APIs Databases, message queues (Kafka), distributed systems Updates Managed by Deployment for rolling updates Built-in rolling updates, rollbacks Ordered, graceful rolling updates and scaling Scale Down Behavior Arbitrary Pods are removed Arbitrary Pods are removed Pods are terminated in reverse ordinal order Export to Sheets","title":"ReplicaSet vs Deployment vs StatefulSet"},{"location":"k8s/k8s/#17-cli-commands-grouped-by-function","text":"This section consolidates kubectl commands for quick reference.","title":"17. CLI Commands Grouped by Function"},{"location":"k8s/k8s/#general-cluster-information","text":"kubectl version Display Kubernetes client and server versions. kubectl cluster-info Display information about the cluster master and services. kubectl config view Display merged kubeconfig settings. kubectl get nodes List cluster nodes. kubectl describe node <node-name> Show detailed information about a node. kubectl top nodes Show CPU/memory usage for nodes (requires Metrics Server).","title":"General Cluster Information"},{"location":"k8s/k8s/#resource-management-crud-operations","text":"","title":"Resource Management (CRUD operations)"},{"location":"k8s/k8s/#create","text":"kubectl apply -f <filename.yaml> Create or update resources defined in a YAML file. (Preferred for declarative management) kubectl create -f <filename.yaml> Create resources if they don't exist. kubectl create deployment <name> --image=<image> Imperatively create a Deployment. kubectl create service <type> <name> --tcp=<port>:<target-port> Imperatively create a Service. kubectl create namespace <name> Create a Namespace. kubectl create configmap <name> --from-literal=<key>=<value> Create a ConfigMap from literals. kubectl create secret generic <name> --from-literal=<key>=<value> Create a Secret from literals. kubectl create secret tls <name> --key=<key-file> --cert=<cert-file> Create a TLS Secret.","title":"Create"},{"location":"k8s/k8s/#get-list","text":"kubectl get all List common resources (pods, deployments, services, replicasets). kubectl get pods List Pods. kubectl get deployments List Deployments. kubectl get services List Services. kubectl get ingress List Ingress resources. kubectl get configmaps List ConfigMaps. kubectl get secrets List Secrets. kubectl get pvc List PersistentVolumeClaims. kubectl get pv List PersistentVolumes. kubectl get namespaces List Namespaces. kubectl get daemonsets List DaemonSets. kubectl get statefulsets List StatefulSets. kubectl get jobs List Jobs. kubectl get cronjobs List CronJobs. kubectl get <resource-type> -n <namespace> Get resources in a specific Namespace. kubectl get <resource-type> -o wide Get resources with more details. kubectl get <resource-type> -l <key>=<value> Get resources filtered by label. kubectl get <resource-type> -o yaml Get resource in YAML format (useful for inspecting current state).","title":"Get (List)"},{"location":"k8s/k8s/#describe-detailed-information","text":"kubectl describe pod <pod-name> Describe a Pod. kubectl describe deployment <deployment-name> Describe a Deployment. kubectl describe service <service-name> Describe a Service. kubectl describe configmap <configmap-name> Describe a ConfigMap. kubectl describe secret <secret-name> Describe a Secret. kubectl describe pvc <pvc-name> Describe a PVC. kubectl describe pv <pv-name> Describe a PV. kubectl describe ing <ingress-name> Describe an Ingress.","title":"Describe (Detailed Information)"},{"location":"k8s/k8s/#delete","text":"kubectl delete -f <filename.yaml> Delete resources defined in a YAML file. kubectl delete pod <pod-name> Delete a Pod. kubectl delete deployment <deployment-name> Delete a Deployment. kubectl delete service <service-name> Delete a Service. kubectl delete ingress <ingress-name> Delete an Ingress. kubectl delete namespace <namespace-name> Delete a Namespace (and all resources within it). kubectl delete all --all -n <namespace> Delete all common resources in a Namespace. kubectl delete pods -l app=my-app Delete Pods by label.","title":"Delete"},{"location":"k8s/k8s/#debugging-and-troubleshooting","text":"kubectl logs <pod-name> Print the logs for a container in a Pod. kubectl logs -f <pod-name> Stream (follow) logs. kubectl logs <pod-name> -c <container-name> Get logs from a specific container in a multi-container Pod. kubectl exec -it <pod-name> -- /bin/bash Execute a shell inside a running container. kubectl cp <source-path> <pod-name>:<destination-path> Copy files into a container. kubectl cp <pod-name>:<source-path> <destination-path> Copy files out of a container. kubectl port-forward <pod-name> <local-port>:<container-port> Forward a local port to a port on a Pod. kubectl get events List recent events in the cluster.","title":"Debugging and Troubleshooting"},{"location":"k8s/k8s/#scaling-and-updates_1","text":"kubectl scale deployment <deployment-name> --replicas=<number> Scale a Deployment to a specific number of replicas. kubectl autoscale deployment <deployment-name> --min=1 --max=5 --cpu-percent=70 Create an HPA (Horizontal Pod Autoscaler). kubectl rollout status deployment/<deployment-name> Check the status of a deployment rollout. kubectl rollout history deployment/<deployment-name> View rollout history. kubectl rollout undo deployment/<deployment-name> Rollback to the previous deployment version. kubectl set image deployment/<deployment-name> <container-name>=<new-image> Update container image in a deployment.","title":"Scaling and Updates"},{"location":"k8s/k8s/#context-and-configuration","text":"kubectl config get-contexts List available contexts. kubectl config use-context <context-name> Switch to a specific context. kubectl config set-context --current --namespace=<namespace-name> Set the default Namespace for the current context.","title":"Context and Configuration"},{"location":"python/python/","text":"yet to start","title":"Python"}]}