{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":""},{"location":"az-204/az-204/","title":"AZ-204 Guide","text":""},{"location":"az-204/az-204/#1-azure-compute-solutions","title":"\ud83d\udd11 1. Azure Compute Solutions","text":""},{"location":"az-204/az-204/#app-service","title":"App Service","text":"<ul> <li>Purpose: Platform-as-a-Service (PaaS) offering for hosting web applications, REST APIs, and mobile backends</li> <li>Features:</li> <li>Automatic scaling</li> <li>Built-in load balancing</li> <li>Support for .NET, .NET Core, Java, Ruby, Node.js, PHP, Python</li> <li>Continuous deployment from GitHub, Azure DevOps, or any Git repo</li> <li>Use Cases: Web applications, API backends, mobile app backends</li> <li>Advantages: No infrastructure management, supports custom domains and SSL</li> </ul>"},{"location":"az-204/az-204/#functions","title":"Functions","text":"<ul> <li>Purpose: Serverless compute service for running event-triggered code</li> <li>Key Characteristics:</li> <li>Pay-per-execution pricing model</li> <li>Automatic scaling</li> <li>Supports multiple languages (C#, Java, JavaScript, Python, PowerShell)</li> <li>Trigger Types:</li> <li>HTTP (API endpoints)</li> <li>Timer (scheduled tasks)</li> <li>Blob Storage (file uploads)</li> <li>Queue Storage (message processing)</li> <li>Event Grid (event processing)</li> <li>Use Cases: Microservices, event processing, lightweight APIs</li> </ul>"},{"location":"az-204/az-204/#aci-azure-container-instances-aks-azure-kubernetes-service","title":"ACI (Azure Container Instances) &amp; AKS (Azure Kubernetes Service)","text":"<ul> <li>ACI:</li> <li>Simplest way to run containers in Azure</li> <li>No orchestration needed</li> <li>Fast startup (seconds)</li> <li> <p>Ideal for: One-off tasks, dev/test scenarios, simple applications</p> </li> <li> <p>AKS:</p> </li> <li>Managed Kubernetes service</li> <li>Full container orchestration</li> <li>Features: Auto-scaling, self-healing, load balancing</li> <li>Ideal for: Microservices architectures, production workloads</li> </ul>"},{"location":"az-204/az-204/#virtual-machines","title":"Virtual Machines","text":"<ul> <li>Purpose: Infrastructure-as-a-Service (IaaS) offering for full control over OS and environment</li> <li>Characteristics:</li> <li>Complete control over the virtualized hardware</li> <li>Supports Windows and Linux</li> <li>Various sizes optimized for different workloads</li> <li>Use Cases:</li> <li>Legacy applications requiring specific OS versions</li> <li>Custom software stacks</li> <li>High-performance computing</li> <li>Applications requiring direct access to hardware</li> </ul>"},{"location":"az-204/az-204/#2-azure-storage-solutions","title":"\ufffd 2. Azure Storage Solutions","text":""},{"location":"az-204/az-204/#blob-storage","title":"Blob Storage","text":"<ul> <li>Purpose: Object storage for massive amounts of unstructured data</li> <li>Access Tiers:</li> <li>Hot: Frequently accessed data</li> <li>Cool: Infrequently accessed data (lower cost)</li> <li>Archive: Rarely accessed data (lowest cost, retrieval latency)</li> <li>Features:</li> <li>Tier lifecycle management</li> <li>Data encryption at rest</li> <li>Shared Access Signatures (SAS) for secure access</li> </ul>"},{"location":"az-204/az-204/#table-storage","title":"Table Storage","text":"<ul> <li>Purpose: NoSQL key-value store for semi-structured data</li> <li>Characteristics:</li> <li>Schemaless design</li> <li>Fast, cost-effective for large volumes of simple data</li> <li>Partition key + row key structure</li> <li>Use Cases: User data, device information, metadata storage</li> </ul>"},{"location":"az-204/az-204/#queue-storage","title":"Queue Storage","text":"<ul> <li>Purpose: Message queue service for asynchronous communication</li> <li>Features:</li> <li>First-In-First-Out (FIFO) processing</li> <li>At-least-once delivery</li> <li>Message time-to-live (TTL) configuration</li> <li>Use Cases: Decoupling application components, load leveling</li> </ul>"},{"location":"az-204/az-204/#file-storage","title":"File Storage","text":"<ul> <li>Purpose: Fully managed file shares using SMB protocol</li> <li>Characteristics:</li> <li>Accessible from cloud or on-premises</li> <li>Supports concurrent access</li> <li>Can be cached on Windows Servers with Azure File Sync</li> <li>Use Cases: Lift-and-shift of file-based applications, shared configuration files</li> </ul>"},{"location":"az-204/az-204/#3azure-security","title":"\ud83d\udd11 3.Azure Security","text":""},{"location":"az-204/az-204/#azure-ad-active-directory","title":"Azure AD (Active Directory)","text":"<ul> <li>Purpose: Cloud-based identity and access management service</li> <li>Features:</li> <li>Single sign-on (SSO)</li> <li>Multi-factor authentication (MFA)</li> <li>Application management</li> <li>Device management</li> <li>B2B and B2C capabilities</li> </ul>"},{"location":"az-204/az-204/#oauth-20openid-connect","title":"OAuth 2.0/OpenID Connect","text":"<ul> <li>OAuth 2.0: Authorization framework for delegated access</li> <li>OpenID Connect: Authentication layer built on OAuth 2.0</li> <li>Flow Types:</li> <li>Authorization Code (web apps)</li> <li>Implicit (SPAs)</li> <li>Client Credentials (service-to-service)</li> <li>Device Code (IoT/CLI)</li> </ul>"},{"location":"az-204/az-204/#managed-identity","title":"Managed Identity","text":"<ul> <li>Purpose: Automatically managed identity in Azure AD for Azure services</li> <li>Types:</li> <li>System-assigned (tied to resource lifecycle)</li> <li>User-assigned (standalone identity)</li> <li>Benefits: Eliminates need for credentials in code</li> </ul>"},{"location":"az-204/az-204/#key-vault","title":"Key Vault","text":"<ul> <li>Purpose: Centralized secrets management</li> <li>Stores:</li> <li>Secrets (passwords, connection strings)</li> <li>Keys (encryption keys)</li> <li>Certificates</li> <li>Features:</li> <li>Access policies and RBAC</li> <li>Hardware security modules (HSMs)</li> <li>Versioning</li> </ul>"},{"location":"az-204/az-204/#rbac-role-based-access-control","title":"RBAC (Role-Based Access Control)","text":"<ul> <li>Purpose: Granular access management for Azure resources</li> <li>Components:</li> <li>Security principal (who)</li> <li>Role definition (what permissions)</li> <li>Scope (where)</li> <li>Built-in Roles:</li> <li>Owner, Contributor, Reader</li> <li>Service-specific roles</li> </ul>"},{"location":"az-204/az-204/#4-monitoring-troubleshooting-and-optimization","title":"\ud83d\udd11 4. Monitoring, Troubleshooting, and Optimization","text":""},{"location":"az-204/az-204/#application-insights","title":"Application Insights","text":"<ul> <li>Purpose: Application performance management (APM) service</li> <li>Monitors:</li> <li>Request rates, response times, failure rates</li> <li>Dependency tracking</li> <li>Exceptions and logs</li> <li>Custom metrics and events</li> </ul>"},{"location":"az-204/az-204/#azure-monitor","title":"Azure Monitor","text":"<ul> <li>Purpose: Comprehensive solution for collecting, analyzing, and acting on telemetry</li> <li>Components:</li> <li>Metrics: Numerical values from resources</li> <li>Logs: Log data with KQL queries</li> <li>Alerts: Notifications based on conditions</li> <li>Workbooks: Interactive reports</li> </ul>"},{"location":"az-204/az-204/#log-analytics","title":"Log Analytics","text":"<ul> <li>Purpose: Log data repository and query engine</li> <li>Features:</li> <li>Kusto Query Language (KQL) for powerful analytics</li> <li>Cross-resource queries</li> <li>Saved queries and functions</li> <li>Integration with Azure Monitor</li> </ul>"},{"location":"az-204/az-204/#alertsautoscale","title":"Alerts/Autoscale","text":"<ul> <li>Alerts:</li> <li>Metric alerts (threshold-based)</li> <li>Log alerts (query-based)</li> <li> <p>Activity log alerts (operations-based)</p> </li> <li> <p>Autoscale:</p> </li> <li>Scale based on metrics or schedules</li> <li>Scale sets for VMs</li> <li>App Service scale-out</li> </ul>"},{"location":"az-204/az-204/#5-data-solutions","title":"\ud83d\udd11 5. Data Solutions","text":""},{"location":"az-204/az-204/#cosmos-db","title":"Cosmos DB","text":"<ul> <li>Purpose: Globally distributed, multi-model database service</li> <li>Consistency Levels:</li> <li>Strong, Bounded Staleness, Session, Consistent Prefix, Eventual</li> <li>APIs Supported:</li> <li>SQL, MongoDB, Cassandra, Gremlin, Table</li> <li>Features:</li> <li>Turnkey global distribution</li> <li>SLA-backed latency and availability</li> <li>Automatic indexing</li> </ul>"},{"location":"az-204/az-204/#sql-database","title":"SQL Database","text":"<ul> <li>Purpose: Fully managed relational database</li> <li>Deployment Models:</li> <li>Single database</li> <li>Elastic pool (shared resources)</li> <li>Managed instance (near-complete SQL Server compatibility)</li> <li>Features:</li> <li>Built-in high availability</li> <li>Intelligent performance tuning</li> <li>Advanced threat protection</li> </ul>"},{"location":"az-204/az-204/#ef-core-entity-framework-core","title":"EF Core (Entity Framework Core)","text":"<ul> <li>Purpose: Object-Relational Mapper (ORM) for .NET</li> <li>Features:</li> <li>LINQ support</li> <li>Change tracking</li> <li>Database migrations</li> <li>Cross-platform</li> <li>Use with Azure: Simplifies data access to Azure SQL, Cosmos DB</li> </ul>"},{"location":"az-204/az-204/#6-integrating-azure-services","title":"\ud83d\udd11 6. Integrating Azure Services","text":""},{"location":"az-204/az-204/#event-grid","title":"Event Grid","text":"<ul> <li>Purpose: Event routing service using publish-subscribe model</li> <li>Characteristics:</li> <li>Fully managed event routing</li> <li>Supports custom and Azure service events</li> <li>Push-based delivery</li> <li>Use Cases: Reacting to blob storage events, custom event processing</li> </ul>"},{"location":"az-204/az-204/#event-hubs","title":"Event Hubs","text":"<ul> <li>Purpose: Big data streaming platform and event ingestion service</li> <li>Features:</li> <li>High throughput (millions of events/sec)</li> <li>Capture feature for automatic data persistence</li> <li>Kafka compatibility</li> <li>Use Cases: IoT telemetry, clickstream analytics</li> </ul>"},{"location":"az-204/az-204/#service-bus","title":"Service Bus","text":"<ul> <li>Purpose: Enterprise messaging with queues and publish-subscribe topics</li> <li>Features:</li> <li>FIFO guarantees</li> <li>Dead-letter queues</li> <li>Duplicate detection</li> <li>Sessions for message ordering</li> <li>Use Cases: Order processing, financial transactions</li> </ul>"},{"location":"az-204/az-204/#logic-apps","title":"Logic Apps","text":"<ul> <li>Purpose: Serverless workflow automation</li> <li>Characteristics:</li> <li>Visual designer</li> <li>200+ connectors</li> <li>Enterprise Integration Pack for B2B scenarios</li> <li>Use Cases: Business process automation, system integration</li> </ul>"},{"location":"az-204/az-204/#api-management-apim","title":"API Management (APIM)","text":"<ul> <li>Purpose: API gateway for publishing, securing, and analyzing APIs</li> <li>Features:</li> <li>Rate limiting</li> <li>Request/response transformation</li> <li>Developer portal</li> <li>Multiple authentication options</li> </ul>"},{"location":"az-204/az-204/#7-deploying-and-managing-resources","title":"\ud83d\udd11 7. Deploying and Managing Resources","text":""},{"location":"az-204/az-204/#arm-templates","title":"ARM Templates","text":"<ul> <li>Purpose: Infrastructure as Code (IaC) for Azure</li> <li>Characteristics:</li> <li>JSON format</li> <li>Declarative syntax</li> <li>Idempotent deployments</li> <li>Modular design with linked templates</li> </ul>"},{"location":"az-204/az-204/#azure-clipowershell","title":"Azure CLI/PowerShell","text":"<ul> <li>Azure CLI:</li> <li>Cross-platform command-line tool</li> <li>Bash-like syntax</li> <li> <p>Interactive mode available</p> </li> <li> <p>Azure PowerShell:</p> </li> <li>PowerShell cmdlets for Azure</li> <li>More granular control than CLI</li> <li>Ideal for Windows environments</li> </ul>"},{"location":"az-204/az-204/#resource-manager-arm","title":"Resource Manager (ARM)","text":"<ul> <li>Purpose: Deployment and management service for Azure</li> <li>Features:</li> <li>Group resources into resource groups</li> <li>Dependency handling</li> <li>Tagging for organization</li> <li>Access control</li> </ul>"},{"location":"az-204/az-204/#cicd-with-github-actionsazure-devops","title":"CI/CD with GitHub Actions/Azure DevOps","text":"<ul> <li>GitHub Actions:</li> <li>YAML-based workflows</li> <li>Tight GitHub integration</li> <li> <p>Marketplace for actions</p> </li> <li> <p>Azure DevOps:</p> </li> <li>Pipelines for CI/CD</li> <li>Test plans</li> <li>Artifact feeds</li> <li>Full application lifecycle management</li> </ul>"},{"location":"az-204/az-204/#8-caching-and-performance-optimization","title":"\ud83d\udd11 8. Caching and Performance Optimization","text":""},{"location":"az-204/az-204/#azure-redis-cache","title":"Azure Redis Cache","text":"<ul> <li>Purpose: In-memory data store based on Redis</li> <li>Tiers:</li> <li>Basic (single node)</li> <li>Standard (replicated)</li> <li>Premium (with persistence and clustering)</li> <li> <p>Use Cases: Session store, output cache, message broker CDN (Content Delivery Network)</p> </li> <li> <p>Purpose: Global content caching for improved performance</p> </li> <li>Features:</li> <li>Edge locations worldwide</li> <li>Custom domains and HTTPS</li> <li>Rules engine for content handling</li> <li>Integration with Storage and Web Apps</li> </ul>"},{"location":"az-204/az-204/#9-api-and-web-app-development","title":"\ud83d\udd11 9. API and Web App Development","text":""},{"location":"az-204/az-204/#secure-api-development","title":"Secure API Development","text":"<ul> <li>Authentication:</li> <li>Azure AD integration</li> <li>OAuth 2.0 flows</li> <li> <p>API keys (for simpler scenarios)</p> </li> <li> <p>Best Practices:</p> </li> <li>Proper status codes</li> <li>Versioning</li> <li>Throttling</li> <li>Input validation</li> </ul>"},{"location":"az-204/az-204/#swaggeropenapi","title":"Swagger/OpenAPI","text":"<ul> <li>Purpose: API description format</li> <li>Features:</li> <li>Machine-readable API contracts</li> <li>Interactive documentation</li> <li>Client SDK generation</li> <li>Integration with API Management</li> </ul>"},{"location":"az-204/az-204/#10-messaging-patterns","title":"\ud83d\udd11 10. Messaging Patterns","text":""},{"location":"az-204/az-204/#queue-based-load-leveling","title":"Queue-based Load Leveling","text":"<ul> <li>Pattern: Use a queue as buffer between components</li> <li>Benefits:</li> <li>Smooths intermittent heavy loads</li> <li>Prevents resource exhaustion</li> <li>Enables asynchronous processing</li> </ul>"},{"location":"az-204/az-204/#competing-consumers","title":"Competing Consumers","text":"<ul> <li>Pattern: Multiple consumers process messages from same queue</li> <li>Benefits:</li> <li>Increased throughput</li> <li>Horizontal scaling</li> <li>Fault tolerance</li> </ul>"},{"location":"az-204/az-204/#publishersubscriber","title":"Publisher/Subscriber","text":"<ul> <li>Pattern: Events distributed to multiple subscribers</li> <li>Azure Services:</li> <li>Event Grid (lightweight)</li> <li>Service Bus Topics (enterprise)</li> <li>Event Hubs (high volume)</li> </ul>"},{"location":"docker/docker/","title":"Docker Notes","text":""},{"location":"docker/docker/#1-introduction-to-docker-and-containerization","title":"1. Introduction to Docker and Containerization","text":"<p>Docker is an open-source platform that enables developers to package applications and their dependencies into standardized units called containers.</p> <p>Containerization is a lightweight alternative to full machine virtualization that:</p> <ul> <li>Packages software in isolated environments</li> <li>Shares the host OS kernel</li> <li>Runs consistently across different infrastructures</li> </ul> <p>Key concepts:</p> <ul> <li>Images: Read-only templates for creating containers</li> <li>Containers: Runnable instances of images</li> <li>Docker Engine: The runtime that manages containers</li> </ul>"},{"location":"docker/docker/#2-benefits-of-using-docker","title":"2. Benefits of Using Docker","text":"Benefit Description Portability Runs identically on any system with Docker installed Efficiency Containers share the OS kernel, using fewer resources than VMs Isolation Applications run in separate, secure environments Scalability Easy to scale services horizontally Consistency Eliminates \"works on my machine\" problems Fast Deployment Containers start in seconds"},{"location":"docker/docker/#3-docker-vs-virtual-machines","title":"3. Docker vs Virtual Machines","text":"Feature Docker Containers Virtual Machines OS Shares host OS Requires full guest OS Startup Time Seconds Minutes Performance Near-native Slight overhead Disk Usage MBs (layered images) GBs (full OS) Isolation Process-level Hardware-level Use Case Microservices, CI/CD Legacy apps, full OS needs"},{"location":"docker/docker/#4-docker-architecture","title":"4. Docker Architecture","text":""},{"location":"docker/docker/#docker-system-components","title":"Docker System Components","text":"<ul> <li>Docker Client: CLI interface (<code>docker</code> command) to interact with the Docker daemon.</li> <li>Docker Host: Runs the Docker daemon and manages containers.</li> <li>Registry: Central repository to store and distribute Docker images (e.g., Docker Hub, private registries).</li> </ul>"},{"location":"docker/docker/#5-key-docker-components","title":"5. Key Docker Components","text":""},{"location":"docker/docker/#docker-core-components","title":"Docker Core Components","text":"Component Description Docker Engine Core runtime (<code>dockerd</code>) Images Immutable templates (e.g., <code>nginx:latest</code>) Containers Runnable instances of images Volumes Persistent data storage Networks Isolated communication channels Dockerfile Blueprint for building images Docker Hub Public image repository"},{"location":"docker/docker/#6-docker-cli-commands","title":"6. Docker CLI Commands","text":""},{"location":"docker/docker/#image-management","title":"\ud83d\udc33 Image Management","text":"<pre><code>docker pull nginx              # Download image\ndocker images                  # List images\ndocker rmi nginx               # Remove image\ndocker build -t myapp .        # Build from Dockerfile\n</code></pre>"},{"location":"docker/docker/#container-management","title":"Container Management","text":"<pre><code>docker run -d -p 80:80 nginx   # Run container\ndocker ps                     # List running containers\ndocker stop &lt;container_id&gt;    # Stop container\ndocker rm &lt;container_id&gt;      # Remove container\ndocker exec -it nginx bash    # Enter running container\n</code></pre>"},{"location":"docker/docker/#volume-management","title":"Volume Management","text":"<pre><code>docker volume create myvol    # Create volume\ndocker volume ls             # List volumes\ndocker volume inspect myvol  # View volume details\n</code></pre>"},{"location":"docker/docker/#network-management","title":"Network Management","text":"<pre><code>docker network create mynet   # Create network\ndocker network ls            # List networks\ndocker network inspect mynet # View network details\n</code></pre>"},{"location":"docker/docker/#7-dockerfile-syntax-and-example","title":"7. Dockerfile Syntax and Example","text":""},{"location":"docker/docker/#common-instructions","title":"Common Instructions","text":"Instruction Purpose FROM Base image WORKDIR Working directory COPY Add files RUN Execute commands EXPOSE Document ports CMD Default command"},{"location":"docker/docker/#example-dockerfile","title":"Example Dockerfile","text":"<pre><code># Multi-stage build for Java app\nFROM maven:3.8-jdk-11 AS build\nWORKDIR /app\nCOPY pom.xml .\nRUN mvn dependency:go-offline\nCOPY src/ ./src/\nRUN mvn package\n\nFROM openjdk:11-jre\nWORKDIR /app\nCOPY --from=build /app/target/myapp.jar .\nEXPOSE 8080\nCMD [\"java\", \"-jar\", \"myapp.jar\"]\n</code></pre>"},{"location":"docker/docker/#8-kubernetes-deployment","title":"8. Kubernetes Deployment","text":""},{"location":"docker/docker/#definition","title":"Definition","text":"<p>Kubernetes is a container orchestration system that automates deployment, scaling, and management of containerized applications.</p>"},{"location":"docker/docker/#full-stack-example","title":"Full-Stack Example","text":"<p>Backend Dockerfile (Spring Boot):</p> <pre><code>FROM maven:3.8-jdk-11 AS build\nWORKDIR /app\nCOPY pom.xml .\nRUN mvn dependency:go-offline\nCOPY src/ ./src/\nRUN mvn package -DskipTests\n\nFROM openjdk:11-jre\nWORKDIR /app\nCOPY --from=build /app/target/backend.jar .\nEXPOSE 8080\nCMD [\"java\", \"-jar\", \"backend.jar\"]\n</code></pre> <p>Frontend Dockerfile (Angular):</p> <pre><code>FROM node:16 AS build\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\nFROM nginx:alpine\nCOPY --from=build /app/dist/frontend /usr/share/nginx/html\nEXPOSE 80\n</code></pre> <p>Kubernetes Deployment (k8s-deployment.yml):</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: backend\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: backend\n  template:\n    metadata:\n      labels:\n        app: backend\n    spec:\n      containers:\n      - name: backend\n        image: myrepo/backend:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: DB_HOST\n          value: \"mysql-service\"\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\nspec:\n  selector:\n    app: backend\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n  type: LoadBalancer\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: frontend\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n    spec:\n      containers:\n      - name: frontend\n        image: myrepo/frontend:latest\n        ports:\n        - containerPort: 80\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\nspec:\n  selector:\n    app: frontend\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 80\n  type: LoadBalancer\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: mysql\nspec:\n  selector:\n    matchLabels:\n      app: mysql\n  template:\n    metadata:\n      labels:\n        app: mysql\n    spec:\n      containers:\n      - name: mysql\n        image: mysql:5.7\n        env:\n        - name: MYSQL_ROOT_PASSWORD\n          value: \"password\"\n        ports:\n        - containerPort: 3306\n        volumeMounts:\n        - name: mysql-persistent-storage\n          mountPath: /var/lib/mysql\n      volumes:\n      - name: mysql-persistent-storage\n        persistentVolumeClaim:\n          claimName: mysql-pv-claim\n\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: mysql-pv-claim\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n</code></pre>"},{"location":"docker/docker/#service-interaction","title":"Service Interaction","text":"<ul> <li>Frontend (Angular) makes API calls to <code>backend-service</code></li> <li>Backend (Spring Boot) connects to <code>mysql-service</code></li> <li>Kubernetes DNS resolves service names automatically</li> </ul>"},{"location":"docker/docker/#9-docker-networking-types","title":"9. Docker Networking Types","text":"Network Type Description Use Case Bridge Default network (NAT) Single-host communication Host Shares host's network High-performance needs Overlay Multi-host network Swarm/Kubernetes clusters Macvlan Assigns MAC addresses Legacy apps needing MAC access"},{"location":"docker/docker/#10-docker-volumes","title":"10. Docker Volumes","text":"Volume Type Description Use Case Named Managed by Docker Persistent data Anonymous Auto-removed Temporary data Bind Mount Host directory Development mounts tmpfs Memory-only Sensitive temp data ------------------ ------------------------ --------------------------"},{"location":"docker/docker/#11-docker-logs-and-inspection","title":"11. Docker Logs and Inspection","text":"<pre><code>docker logs &lt;container&gt;        # View logs\ndocker logs -f &lt;container&gt;     # Follow logs in real-time\ndocker exec -it &lt;container&gt; bash  # Enter container's shell\ndocker inspect &lt;container&gt;     # Detailed container info\ndocker stats                   # Show live resource usage\n</code></pre>"},{"location":"docker/docker/#12-docker-security-best-practices","title":"12. Docker Security Best Practices","text":"<ul> <li>Use official images from trusted sources</li> <li>Run containers as non-root user:</li> </ul> <pre><code>USER appuser\n</code></pre> <ul> <li>Scan images for vulnerabilities</li> <li>Limit container capabilities:</li> </ul> <pre><code>docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE\n</code></pre> <ul> <li>Use secrets for sensitive data</li> <li>Keep Docker Engine and images updated</li> </ul>"},{"location":"docker/docker/#13-docker-in-cicd","title":"13. Docker in CI/CD","text":"<p>Typical CI/CD Pipeline:</p> <ol> <li>Code commit triggers build</li> <li>Docker image is built and tested</li> <li>Image pushed to registry</li> <li>Kubernetes deploys new version</li> <li>Automated rollback if tests fail</li> </ol> <p>GitHub Actions snippet:</p> <pre><code>- name: Build and push\n  uses: docker/build-push-action@v2\n  with:\n    push: true\n    tags: user/app:latest\n</code></pre>"},{"location":"docker/docker/#14-dockerfile-best-practices","title":"14. Dockerfile Best Practices","text":"<ul> <li>Use <code>.dockerignore</code> to exclude unnecessary files</li> <li>Order instructions from least to most frequently changed</li> <li>Use multi-stage builds to reduce image size</li> <li>Pin versions for base images and dependencies</li> <li>Minimize layers by combining <code>RUN</code> commands</li> <li>Use smallest suitable base image (e.g., Alpine Linux)</li> </ul>"},{"location":"docker/docker/#15-cleanup-commands","title":"15. Cleanup Commands","text":"<pre><code>docker system prune           # Remove unused objects\ndocker system prune -a       # Remove all unused images\ndocker volume prune          # Remove unused volumes\ndocker network prune         # Remove unused networks\ndocker rm $(docker ps -aq)   # Remove all stopped containers\n</code></pre>"},{"location":"docker/docker/#16-conclusion-why-docker-is-essential","title":"16. Conclusion: Why Docker is Essential","text":"<p>Docker has become fundamental to modern DevOps because it:</p> <ul> <li>Standardizes application packaging and deployment</li> <li>Enables microservices architecture</li> <li>Facilitates CI/CD pipelines</li> <li>Improves development/production parity</li> <li>Optimizes resource utilization</li> <li>Simplifies scaling and orchestration (with Kubernetes)</li> </ul> <p>When combined with Kubernetes, Docker provides a complete solution for building, shipping, and running distributed applications at scale.</p>"},{"location":"docker/dummy/docker-1-intro/","title":"Docker 1 intro","text":""},{"location":"docker/dummy/docker-1-intro/#docker-1-intromd","title":"docker-1-intro.md","text":""},{"location":"docker/dummy/docker-2-benefits/","title":"Docker 2 benefits","text":""},{"location":"docker/dummy/docker-2-benefits/#docker-2-benefitsmd","title":"docker-2-benefits.md","text":""},{"location":"docker/dummy/docker-3-vm-vs-containers/","title":"Docker 3 vm vs containers","text":""},{"location":"docker/dummy/docker-3-vm-vs-containers/#hhhh","title":"hhhh","text":""},{"location":"docker/dummy/docker-4-architecture/","title":"Docker 4 architecture","text":""},{"location":"docker/dummy/docker-4-architecture/#docker-4-architecturemd","title":"docker-4-architecture.md","text":""},{"location":"k8s/k8s/","title":"Kubernetes Notes","text":""},{"location":"k8s/k8s/#1-what-is-kubernetes","title":"1. What is Kubernetes?","text":"<ul> <li>Kubernetes, often abbreviated as K8s.</li> <li>It is an open-source platform designed to automate the deployment, scaling, and management of containerized applications. </li> <li>It groups containers that make up an application into logical units for easy management and discovery.</li> </ul>"},{"location":"k8s/k8s/#purpose-of-container-orchestration","title":"Purpose of Container Orchestration","text":"<p>In modern software development, applications are increasingly built using containers (like Docker). While containers solve the works on my machine problem and provide isolation, managing many containers across multiple servers (a cluster) becomes complex. This is where container orchestration comes in:</p> <ul> <li> <p>Deployment Automation: Automates the process of getting your application containers running on a cluster.</p> </li> <li> <p>Scaling: Automatically adjusts the number of container instances based on demand, ensuring performance and availability.</p> </li> <li> <p>Self-Healing: Automatically restarts failed containers, replaces unhealthy ones, and reschedules containers on healthy nodes.</p> </li> <li> <p>Load Balancing: Distributes incoming traffic across multiple container instances to ensure even load.</p> </li> <li> <p>Resource Management: Efficiently allocates compute resources (CPU, memory) to containers across the cluster.</p> </li> <li> <p>Service Discovery: Allows containers to find and communicate with each other easily.</p> </li> <li> <p>Configuration Management: Manages application configurations and sensitive data securely.</p> </li> </ul>"},{"location":"k8s/k8s/#comparison-docker-vs-kubernetes","title":"Comparison: Docker vs Kubernetes","text":"<p>It's a common misconception that Docker and Kubernetes are competing technologies. In reality, they often complement each other.</p> Feature Docker (Engine/CLI) Kubernetes Primary Role Containerization platform (build, run, share containers) Container Orchestration (manage, scale, deploy containers) Scope Single host (primarily) Cluster of hosts (distributed systems) Focus Packaging applications into portable units Managing the lifecycle of many containers at scale Deployment <code>docker run</code> on a single machine Automated deployment across a cluster Scaling Manual scaling (e.g., <code>docker run</code> multiple times) Automatic scaling based on policies Self-Healing Limited (e.g., restart policy) Robust (restarts, reschedules, replaces failed containers) Networking Basic networking for containers on a single host Advanced networking for inter-container communication across cluster Load Balancing Manual or requires external tools Built-in load balancing and service discovery Configuration Environment variables, bind mounts ConfigMaps, Secrets, Volumes Complexity Relatively simple for single-container apps Higher initial learning curve, powerful for complex apps Typical Usage Local development, running single services Production deployments of microservices, distributed apps"},{"location":"k8s/k8s/#analogy","title":"\ud83e\udde0 Analogy:","text":"<p>If Docker is the engine for your car (application), then Kubernetes is the traffic management system that ensures all cars on the road (applications) reach their destination efficiently and safely.</p>"},{"location":"k8s/k8s/#2-kubernetes-architecture","title":"2. Kubernetes Architecture","text":"<p>Kubernetes operates on a master-worker architecture. A Kubernetes cluster consists of at least one Master Node and multiple Worker Nodes.</p> <p>Diagram:</p> <p></p>"},{"location":"k8s/k8s/#master-node-components","title":"Master Node Components","text":"<p>The Master Node (also called Control Plane) manages the cluster and ensures that it remains in the desired state. It includes the following components:</p>"},{"location":"k8s/k8s/#kube-apiserver","title":"kube-apiserver","text":"<ul> <li>Purpose: The front-end for the Kubernetes control plane. All communication with the cluster (from <code>kubectl</code> or other components) goes through the API server.</li> <li>Role: Exposes the Kubernetes API, handles REST operations, validates requests, and updates <code>etcd</code>.</li> <li>Interaction: It's the only component that directly talks to <code>etcd</code>.</li> </ul>"},{"location":"k8s/k8s/#etcd","title":"etcd","text":"<ul> <li>Purpose: A consistent and highly available key-value store that holds all cluster data (cluster state, configuration, metadata).</li> <li>Role: The single source of truth for the Kubernetes cluster.</li> <li>Interaction: Only the <code>kube-apiserver</code> accesses <code>etcd</code>.</li> </ul>"},{"location":"k8s/k8s/#kube-scheduler","title":"kube-scheduler","text":"<ul> <li>Purpose: Watches for newly created Pods that do not have an assigned node and selects a node for them to run on.</li> <li>Role: Considers resource requirements, hardware/software/policy constraints, affinity/anti-affinity rules, and data locality.</li> </ul>"},{"location":"k8s/k8s/#kube-controller-manager","title":"kube-controller-manager","text":"<ul> <li>Purpose: Runs controller processes. Controllers are control loops that watch the shared state of the cluster via the API server and make changes to drive the current state towards the desired state.</li> <li>Role: Manages various controllers:</li> <li>Node Controller: Detects and responds when nodes go down.</li> <li>Replication Controller: Ensures the correct number of Pods are maintained for each ReplicaSet or ReplicationController.</li> <li>Endpoints Controller: Populates the Endpoints object (connecting Services and Pods).</li> <li>Service Account &amp; Token Controllers: Creates default service accounts and API access tokens for new namespaces.</li> </ul>"},{"location":"k8s/k8s/#worker-node-components","title":"Worker Node Components","text":"<p>Worker Nodes (also called Minions or just Nodes) run the actual containerized applications.</p>"},{"location":"k8s/k8s/#kubelet","title":"Kubelet","text":"<ul> <li>Purpose: An agent that runs on</li> </ul>"},{"location":"k8s/k8s/#3-kubernetes-core-concepts","title":"3. Kubernetes Core Concepts","text":"<p>Understanding these fundamental building blocks is crucial for working with Kubernetes.</p>"},{"location":"k8s/k8s/#pod","title":"Pod","text":"<ul> <li>Definition: The smallest deployable unit in Kubernetes. A Pod represents a single instance of a running process in your cluster.</li> </ul>"},{"location":"k8s/k8s/#characteristics","title":"Characteristics:","text":"<ul> <li>Atomic Unit: Can contain one or more tightly coupled containers that share the same network namespace, IP address, and storage.</li> <li>Ephemeral: Pods are designed to be short-lived. If a Pod dies, Kubernetes creates a new one.</li> <li>Shared Resources: Containers share localhost, networking stack (IP, ports), and volumes.</li> </ul> <p>Analogy: A Pod is like a small logical machine that hosts your app\u2019s components.</p> <p>When to use multiple containers in a Pod? Use for sidecar containers (e.g., logging agent, data syncer, proxy) that support the main container.</p>"},{"location":"k8s/k8s/#replicaset","title":"ReplicaSet","text":"<ul> <li>Definition: Ensures a specified number of Pod replicas are running at all times.</li> <li>Purpose: Maintains availability and scaling. Replaces failed Pods, removes excess.</li> <li>Usage: Typically managed through Deployments, not directly created.</li> </ul>"},{"location":"k8s/k8s/#deployment","title":"Deployment","text":"<ul> <li>Definition: A higher-level abstraction for managing ReplicaSets and Pods declaratively.</li> <li>Purpose: Manages the desired state (e.g., number of replicas, Pod version).</li> </ul>"},{"location":"k8s/k8s/#key-features","title":"Key Features:","text":"<ul> <li>Rolling Updates: Update with zero downtime.</li> <li>Rollbacks: Revert to previous versions if needed.</li> <li>Scaling: Scale the number of replicas up or down.</li> </ul> <p>Analogy: Deployment is like a project manager for your app, ensuring correct versioning and scaling.</p>"},{"location":"k8s/k8s/#service","title":"Service","text":"<ul> <li>Definition: An abstraction that exposes a set of Pods as a network service.</li> <li>Purpose: Provides a stable IP/DNS name and acts as a load balancer.</li> </ul>"},{"location":"k8s/k8s/#types-of-services","title":"Types of Services:","text":"<ul> <li>ClusterIP (default) </li> <li>Internal-only access.  </li> <li> <p>Use for backend/internal services.</p> </li> <li> <p>NodePort </p> </li> <li>Exposes service on each node\u2019s static port.  </li> <li>Access via <code>NodeIP:NodePort</code>.  </li> <li> <p>Use for testing/dev environments.</p> </li> <li> <p>LoadBalancer </p> </li> <li>Externally accessible via a cloud load balancer (e.g., AWS ELB).  </li> <li> <p>Use for production-grade public apps.</p> </li> <li> <p>ExternalName </p> </li> <li>Maps service to an external DNS name (e.g., <code>my.db.example.com</code>).  </li> <li>No proxying \u2014 returns a CNAME record.</li> </ul> <p>Analogy: A Service is like a stable phone number \u2014 callers reach your app even if Pods change.</p>"},{"location":"k8s/k8s/#namespace","title":"Namespace","text":"<ul> <li>Definition: Provides a scope for resource names. Useful for isolating resources between teams or environments.</li> <li>Purpose: Logical partitioning of resources.</li> </ul>"},{"location":"k8s/k8s/#default-namespaces","title":"Default Namespaces:","text":"<ul> <li><code>default</code>: For general workloads.</li> <li><code>kube-system</code>: Kubernetes system resources.</li> <li><code>kube-public</code>: Public resources.</li> <li><code>kube-node-lease</code>: Node heartbeat tracking.</li> </ul> <p>Best Practice: Use separate Namespaces for dev, staging, production, and teams.</p>"},{"location":"k8s/k8s/#configmap-secret","title":"ConfigMap &amp; Secret","text":""},{"location":"k8s/k8s/#configmap","title":"ConfigMap:","text":"<ul> <li>Definition: Stores non-confidential config data as key-value pairs.</li> <li>Purpose: Decouple configuration from code.</li> <li>Usage: As environment variables, command args, or mounted files.</li> </ul>"},{"location":"k8s/k8s/#secret","title":"Secret:","text":"<ul> <li>Definition: Stores sensitive data like passwords, tokens, keys.</li> <li>Purpose: Securely handle confidential information.</li> <li>Security: Base64 encoded by default. Enable encryption for production.</li> <li>Usage: Similar to ConfigMaps, but for secret data.</li> </ul> <p>Best Practice: Never store secrets in ConfigMaps.</p>"},{"location":"k8s/k8s/#volume-persistentvolumeclaim-pvc","title":"Volume &amp; PersistentVolumeClaim (PVC)","text":""},{"location":"k8s/k8s/#volume","title":"Volume:","text":"<ul> <li>Definition: A directory accessible to containers in a Pod.</li> <li>Purpose: Shares data between containers or persists data beyond container lifespan.</li> </ul>"},{"location":"k8s/k8s/#basic-volume-types","title":"Basic Volume Types:","text":"<ul> <li><code>emptyDir</code>: Temporary storage, tied to Pod life.</li> <li><code>hostPath</code>: Mounts node\u2019s file path (not recommended in production).</li> </ul>"},{"location":"k8s/k8s/#persistentvolume-pv","title":"PersistentVolume (PV):","text":"<ul> <li>Definition: Pre-provisioned storage in the cluster.</li> <li>Purpose: Durable, cluster-level storage.</li> </ul>"},{"location":"k8s/k8s/#persistentvolumeclaim-pvc","title":"PersistentVolumeClaim (PVC):","text":"<ul> <li>Definition: User request for PV.</li> <li>Purpose: Abstracts storage request from underlying storage.</li> </ul> <p>Analogy: PV is like a raw hard drive, PVC is the user\u2019s storage request, and Volume is the Pod\u2019s access point.</p>"},{"location":"k8s/k8s/#other-workload-resources","title":"Other Workload Resources","text":""},{"location":"k8s/k8s/#daemonset","title":"DaemonSet","text":"<ul> <li>Purpose: Ensures a Pod runs on all (or some) nodes.</li> <li>Use Case: Cluster-wide agents (e.g., log collectors, metrics exporters).</li> </ul>"},{"location":"k8s/k8s/#statefulset","title":"StatefulSet","text":"<ul> <li>Purpose: Manages stateful applications.</li> <li>Use Case: Databases (e.g., MySQL, Kafka) needing stable identities and storage.</li> </ul>"},{"location":"k8s/k8s/#job","title":"Job","text":"<ul> <li>Purpose: Creates Pods that run to completion.</li> <li>Use Case: One-off or batch tasks (e.g., report generation).</li> </ul>"},{"location":"k8s/k8s/#cronjob","title":"CronJob","text":"<ul> <li>Purpose: Runs Jobs on a schedule (like Unix cron).</li> <li>Use Case: Periodic backups, scheduled reports.</li> </ul>"},{"location":"k8s/k8s/#4-kubernetes-objects-and-yaml-syntax","title":"4. Kubernetes Objects and YAML Syntax","text":"<p>Kubernetes resources are defined using YAML (<code>YAML Ain't Markup Language</code>) files. These files describe the desired state of objects in your cluster.</p>"},{"location":"k8s/k8s/#anatomy-of-a-kubernetes-manifest","title":"Anatomy of a Kubernetes Manifest","text":"<p>Every Kubernetes YAML manifest generally contains four top-level fields:</p>"},{"location":"k8s/k8s/#1-apiversion","title":"1. <code>apiVersion</code>","text":"<ul> <li>What it is: Specifies which version of the Kubernetes API you're using.</li> <li>Examples:</li> <li><code>v1</code> (for core resources like Pod, Service)</li> <li><code>apps/v1</code> (for Deployments, StatefulSets)</li> <li><code>batch/v1</code> (for Jobs, CronJobs)</li> </ul>"},{"location":"k8s/k8s/#2-kind","title":"2. <code>kind</code>","text":"<ul> <li>What it is: The type of Kubernetes object being created.</li> <li>Examples: <code>Pod</code>, <code>Deployment</code>, <code>Service</code>, <code>ConfigMap</code>, <code>PersistentVolumeClaim</code></li> </ul>"},{"location":"k8s/k8s/#3-metadata","title":"3. <code>metadata</code>","text":"<ul> <li>What it contains:</li> <li><code>name</code>: Unique name of the object within a Namespace.</li> <li><code>namespace</code>: (Optional) Scope of the resource. Defaults to <code>default</code> if not specified.</li> <li><code>labels</code>: Key-value pairs used for organization and selection.</li> <li><code>annotations</code>: Additional metadata (non-identifying, like build version or tool info).</li> </ul>"},{"location":"k8s/k8s/#4-spec","title":"4. <code>spec</code>","text":"<ul> <li>What it is: Defines the desired state of the object.</li> <li>Note: The structure under <code>spec</code> depends on the object's <code>kind</code>.</li> </ul>"},{"location":"k8s/k8s/#example-basic-yaml-structure","title":"Example Basic YAML Structure","text":"<pre><code>apiVersion: &lt;api-version&gt;\nkind: &lt;kind-of-object&gt;\nmetadata:\n  name: &lt;object-name&gt;\n  namespace: &lt;optional-namespace&gt;\n  labels:\n    app: &lt;application-name&gt;\n    tier: &lt;tier-name&gt;\nspec:\n  # Desired state of the object (varies by kind)\n</code></pre>"},{"location":"k8s/k8s/#example-yaml-files","title":"Example YAML Files","text":"<p>These YAML files define various Kubernetes resources like Pods, Deployments, Services, ConfigMaps, and PVCs.</p>"},{"location":"k8s/k8s/#pod-example","title":"\ud83e\uddf1 Pod Example","text":"<pre><code># my-pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-nginx-pod\n  labels:\n    app: web\n    tier: frontend\nspec:\n  containers:\n    - name: nginx-container\n      image: nginx:latest\n      ports:\n        - containerPort: 80\n</code></pre> <p>Deployment Example</p> <pre><code># my-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-web-deployment\n  labels:\n    app: web\nspec:\n  replicas: 3 # Desired number of Pod replicas\n  selector:\n    matchLabels:\n      app: web # Selects Pods with label app: web\n  template: # Pod template\n    metadata:\n      labels:\n        app: web\n        version: v1.0.0\n    spec:\n      containers:\n      - name: nginx-container\n        image: nginx:1.21.6\n        ports:\n        - containerPort: 80\n        resources: # Optional: Define resource requests and limits\n          requests:\n            memory: \"64Mi\"\n            cpu: \"250m\" # 0.25 CPU core\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\" # 0.5 CPU core\n</code></pre> <p>Service Example (NodePort)</p> <pre><code># my-service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-web-service\n  labels:\n    app: web\nspec:\n  selector:\n    app: web # Selects Pods with label app: web\n  type: NodePort # Exposes service on a static port on each node\n  ports:\n    - protocol: TCP\n      port: 80 # Service port (internal)\n      targetPort: 80 # Container port\n      nodePort: 30007 # Optional: Specific node port (range 30000-32767)\n</code></pre> <p>ConfigMap Example</p> <pre><code># my-configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  # Key-value pairs for configuration\n  APP_COLOR: blue\n  APP_ENV: development\n  database.url: jdbc:mysql://localhost:3306/mydb\n\n</code></pre> <p>PersistentVolumeClaim (PVC) Example</p> <pre><code># my-pvc.yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-data-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce # Can be mounted as read-write by a single node\n  resources:\n    requests:\n      storage: 5Gi # Request 5 Gigabytes of storage\n  # storageClassName: standard # Optional: If you have a specific StorageClass\n</code></pre>"},{"location":"k8s/k8s/#5-kubernetes-cli-kubectl","title":"5. Kubernetes CLI (kubectl)","text":"<ul> <li><code>kubectl</code> is the command-line tool for interacting with Kubernetes clusters.</li> </ul>"},{"location":"k8s/k8s/#cluster-interaction","title":"\ud83d\udd0c Cluster Interaction","text":"<ul> <li><code>kubectl</code> communicates with the kube-apiserver on the Control Plane (Master Node).</li> </ul>"},{"location":"k8s/k8s/#common-kubectl-commands-grouped-by-function","title":"\ud83d\udee0\ufe0f Common <code>kubectl</code> Commands (Grouped by Function)","text":""},{"location":"k8s/k8s/#creation-application","title":"\u2705 Creation &amp; Application","text":"<p>Apply a configuration (create or update):</p> <pre><code>kubectl apply -f &lt;filename.yaml&gt;\nkubectl apply -f &lt;directory_containing_yamls&gt;/\n# Example:\nkubectl apply -f my-deployment.yaml\n</code></pre> <p>Best Practice:  Always use kubectl apply for managing resources, as it's idempotent (can be run multiple times safely).</p> <p>Create a resource (if it doesn't exist):</p> <pre><code>\nkubectl create -f &lt;filename.yaml&gt; # Creates only if resource doesn't exist\nkubectl create deployment my-app --image=nginx # Quick imperitive command\n</code></pre> <p>Note: <code>kubectl create</code> is generally used for initial setup or one-off resources. <code>kubectl apply</code> is preferred for declarative, version-controlled resource management.</p>"},{"location":"k8s/k8s/#getting-information","title":"\ud83d\udd0d Getting Information","text":""},{"location":"k8s/k8s/#list-resources","title":"List resources:","text":"<pre><code>\nkubectl get pods\nkubectl get deployments\nkubectl get services\nkubectl get all # Get common resources (pods, services, deployments, replicasets)\nkubectl get pods -o wide # Show more details (Node IP, Pod IP)\nkubectl get pods -n &lt;namespace&gt; # Get pods in a specific namespace\nkubectl get pods --show-labels # Show labels\n</code></pre>"},{"location":"k8s/k8s/#describe-a-resource-detailed-information","title":"Describe a resource (detailed information):","text":"<pre><code>\nkubectl describe pod &lt;pod-name&gt;\nkubectl describe deployment &lt;deployment-name&gt;\nkubectl describe service &lt;service-name&gt;\n# Example:\nkubectl describe pod my-nginx-pod-abc12\n</code></pre> <p>Purpose: Shows events, status, resource limits, volumes, etc. Indispensable for     troubleshooting.</p>"},{"location":"k8s/k8s/#view-logs-from-a-container-in-a-pod","title":"View logs from a container in a Pod:","text":"<pre><code>\nkubectl logs &lt;pod-name&gt;\nkubectl logs -f &lt;pod-name&gt; # Follow logs in real-time\nkubectl logs &lt;pod-name&gt; -c &lt;container-name&gt; # For multi-container pods\n</code></pre>"},{"location":"k8s/k8s/#execute-a-command-in-a-running-container","title":"Execute a command in a running container:","text":"<pre><code>kubectl exec -it &lt;pod-name&gt; -- /bin/bash # Get a shell into the container\nkubectl exec &lt;pod-name&gt; -- ls /app # Run a command\n# Example:\nkubectl exec -it my-nginx-pod-abc12 -- bash\n</code></pre>"},{"location":"k8s/k8s/#copy-files-tofrom-a-container","title":"Copy files to/from a container:","text":"<pre><code>kubectl cp &lt;source-path&gt; &lt;pod-name&gt;:&lt;destination-path&gt;\nkubectl cp &lt;pod-name&gt;:&lt;source-path&gt; &lt;destination-path&gt;\n# Example:\nkubectl cp my-local-file.txt my-nginx-pod-abc12:/usr/share/nginx/html/\n</code></pre>"},{"location":"k8s/k8s/#view-resource-usage-requires-metrics-server","title":"View resource usage (requires Metrics Server):","text":"<pre><code>kubectl top nodes\nkubectl top pods\n</code></pre>"},{"location":"k8s/k8s/#check-cluster-events","title":"Check cluster events:","text":"<pre><code>kubectl get events\n</code></pre>"},{"location":"k8s/k8s/#deletion","title":"Deletion:","text":"<p>Delete a resource:</p> <pre><code>kubectl delete -f &lt;filename.yaml&gt;\nkubectl delete pod &lt;pod-name&gt;\nkubectl delete deployment &lt;deployment-name&gt;\nkubectl delete service &lt;service-name&gt;\nkubectl delete namespace &lt;namespace-name&gt; # Deletes everything in that namespace\n# Example:\nkubectl delete -f my-deployment.yaml\nkubectl delete deployment my-web-deployment\n</code></pre>"},{"location":"k8s/k8s/#scaling-and-updates","title":"Scaling and Updates:","text":"<p>Scale a Deployment:</p> <pre><code>kubectl scale deployment &lt;deployment-name&gt; --replicas=&lt;number&gt;\n# Example:\nkubectl scale deployment my-web-deployment --replicas=5\n</code></pre> <p>Rollout status/history/undo:</p> <pre><code>kubectl rollout status deployment/&lt;deployment-name&gt;\nkubectl rollout history deployment/&lt;deployment-name&gt;\nkubectl rollout undo deployment/&lt;deployment-name&gt; # Rollback to previous version\n</code></pre>"},{"location":"k8s/k8s/#namespace-management","title":"Namespace Management:","text":"<p>List namespaces:</p> <pre><code>kubectl get namespaces\n</code></pre> <p>Create a namespace:</p> <pre><code>kubectl create namespace &lt;namespace-name&gt;\n# Example: kubectl create namespace dev-env\n</code></pre> <p>Set default namespace for current context:</p> <pre><code>kubectl config set-context --current --namespace=&lt;namespace-name&gt;\n# Example: kubectl config set-context --current --namespace=dev-env\n</code></pre> <p>This makes your infrastructure version-controllable and repeatable.</p>"},{"location":"k8s/k8s/#best-practices-for-kubectl","title":"Best Practices for <code>kubectl</code>","text":"<p>Declarative vs. Imperative: While imperative commands (<code>kubectl run</code>, <code>kubectl create deployment</code>) are useful    for quick tests, prefer declarative management using YAML files with:  </p> <p><code>kubectl apply -f &lt;file.yaml&gt;</code></p> <ul> <li>This makes your infrastructure version-controllable and repeatable.</li> </ul>"},{"location":"k8s/k8s/#namespaces","title":"\ud83d\udcdb Namespaces","text":"<ul> <li>Always specify the namespace using the <code>-n &lt;namespace&gt;</code> flag if you're not operating in the default namespace.</li> </ul> <p><code>bash   kubectl get pods -n dev</code></p>"},{"location":"k8s/k8s/#labels","title":"\ud83c\udff7\ufe0f Labels","text":"<p>Use labels extensively for organizing and selecting Kubernetes resources.</p> <ul> <li>Labels are key-value pairs used to categorize resources.</li> <li>They enable filtering, selection, and grouping for operations like deployments, services, and monitoring.</li> </ul> <p>Example (YAML):</p> <pre><code>metadata:\n  labels:\n    app: my-app\n    environment: dev\n</code></pre>"},{"location":"k8s/k8s/#describe-for-troubleshooting","title":"\ud83d\udee0\ufe0f Describe for Troubleshooting","text":"<p>When something isn't working, <code>kubectl describe</code> should be your first stop.</p> <ul> <li>It provides detailed insights into the resource's current state.</li> <li>Useful information includes:</li> <li>Events and warnings</li> <li>Pod scheduling and status</li> <li>Liveness/readiness probe results</li> <li>Volume mounts and conditions</li> </ul> <p>Example:</p> <pre><code>kubectl describe pod my-app-pod\n</code></pre>"},{"location":"k8s/k8s/#logs-for-application-insights","title":"\ud83d\udcc4 Logs for Application Insights","text":"<p>Use <code>kubectl logs</code> to check logs and understand application behavior.</p> <p>Examples:</p> <pre><code>kubectl logs &lt;pod-name&gt;\nkubectl logs -f &lt;pod-name&gt;              # Follow logs in real time\nkubectl logs &lt;pod-name&gt; -c &lt;container&gt;  # For multi-container Pods\n</code></pre>"},{"location":"k8s/k8s/#6-kubernetes-networking","title":"6. Kubernetes Networking","text":"<p>Kubernetes networking enables communication between Pods, Services, and the outside world. It's a complex topic, but here's a simplified overview.</p>"},{"location":"k8s/k8s/#key-principles","title":"Key Principles:","text":"<ul> <li>Every Pod gets its own unique IP address.</li> <li>Pods on a node can communicate with all Pods on all other nodes without NAT.</li> <li>Agents on a node (e.g., kubelet) can communicate with all Pods on that node.</li> </ul>"},{"location":"k8s/k8s/#pod-to-pod-communication","title":"Pod-to-Pod Communication","text":"<ul> <li>When Pods are on the same Node: They communicate directly using their Pod IP addresses.</li> <li>When Pods are on different Nodes: Traffic is routed between nodes by the underlying Container Network Interface (CNI) plugin (e.g., Calico, Flannel, Weave Net). Each Pod has a unique IP address within the cluster, and these IPs are routable across the cluster.</li> </ul>"},{"location":"k8s/k8s/#service-to-service-communication","title":"Service-to-Service Communication","text":"<ul> <li>Services provide a stable IP address and DNS name for a set of Pods.</li> <li>Pods communicate with each other via Services using the Service's stable IP address or DNS name.</li> <li><code>kube-proxy</code> on each node ensures that traffic sent to a Service's IP is correctly load-balanced to the healthy Pods backing that Service.</li> </ul> <p>Example: A frontend Pod wants to talk to a backend Pod. Instead of knowing the backend Pod's ephemeral IP, it sends traffic to the backend-service name or IP, and Kubernetes handles the routing and load balancing.</p>"},{"location":"k8s/k8s/#dns-resolution","title":"DNS Resolution","text":"<ul> <li>Kubernetes provides internal DNS resolution.</li> <li>Services are automatically assigned DNS names.</li> <li>Within the same Namespace: <code>service-name</code></li> <li>Across Namespaces: <code>service-name.namespace-name.svc.cluster.local</code></li> <li>This allows Pods to discover and communicate with Services by name rather than by IP address.</li> </ul>"},{"location":"k8s/k8s/#network-policies-basic-intro","title":"Network Policies (Basic Intro)","text":"<ul> <li>Definition: Kubernetes Network Policies specify how groups of Pods are allowed to communicate with each other and with external network endpoints.</li> <li>Purpose: Enhance security by restricting network access between Pods. By default, Pods are non-isolated and can accept traffic from any source.</li> <li>Requirement: Network Policies require a CNI plugin that supports them (e.g., Calico, Cilium).</li> </ul> <p>Analogy: Network Policies are like firewall rules for your Pods.</p>"},{"location":"k8s/k8s/#7-kubernetes-storage","title":"7. Kubernetes Storage","text":"<p>Kubernetes provides robust mechanisms for managing storage, allowing applications to persist data beyond the life of a single container or Pod.</p>"},{"location":"k8s/k8s/#types-of-volumes","title":"Types of Volumes","text":"<p>Kubernetes Volumes are directories accessible to the containers in a Pod. The data in a Volume persists as long as the Pod exists. Some common types:</p>"},{"location":"k8s/k8s/#emptydir","title":"<code>emptyDir</code>:","text":"<ul> <li>Purpose: A simple, empty volume created when a Pod is first assigned to a node.</li> <li>Persistence: Its contents are deleted when the Pod is removed from the node.</li> <li>Use Case: Temporary scratch space, sharing files between containers in the same Pod.</li> </ul>"},{"location":"k8s/k8s/#hostpath","title":"<code>hostPath</code>:","text":"<ul> <li>Purpose: Mounts a file or directory from the host node's filesystem into a Pod.</li> <li>Persistence: Data persists beyond Pod lifecycle, but tied to a specific node.</li> <li>Use Case: Primarily for system-level Pods (e.g., monitoring agents), or if you need access to host files.</li> </ul> <p>Caution: Generally discouraged for production applications due to lack of portability and potential security risks.</p>"},{"location":"k8s/k8s/#persistentvolume-pv-and-persistentvolumeclaim-pvc-covered-in-section-3","title":"<code>persistentVolume (PV)</code> and <code>persistentVolumeClaim (PVC)</code>: (Covered in Section 3)","text":"<ul> <li>PV: A piece of storage in the cluster, provisioned by an admin (or dynamically).</li> <li>PVC: A request for storage by a user, that binds to an available PV.</li> <li>Purpose: Provides a way to consume durable storage abstractly.</li> <li>Use Case: Databases, persistent application data.</li> </ul>"},{"location":"k8s/k8s/#storageclasses-basic-overview","title":"StorageClasses (Basic Overview)","text":"<ul> <li>Definition: An API object that describes the \"classes\" of storage offered in a cluster.</li> <li>Purpose: Allows administrators to define different types of storage (e.g., \"fast-SSD\", \"cheap-HDD\", \"network-storage\") and users to request them without knowing the underlying storage details.</li> <li>Dynamic Provisioning: When a PVC requests a <code>storageClassName</code>, the StorageClass can dynamically provision a matching PV for that PVC.</li> </ul> <p>Analogy: StorageClass is like a catalog of storage options, and PVC is like ordering from that catalog.</p>"},{"location":"k8s/k8s/#8-kubernetes-services-comparison-table","title":"8. Kubernetes Services Comparison Table","text":"<p>Here's a comparison of the main Service types in Kubernetes, including Ingress for external access.</p> Feature ClusterIP NodePort LoadBalancer Ingress Exposure Internal to cluster On each Node's IP at a static port External IP provisioned by cloud provider HTTP/HTTPS routing based on host/path Accessibility Only from within the cluster From outside the cluster (via NodeIP:NodePort) From anywhere on the internet From anywhere on the internet (via DNS of Ingress controller) Load Balancing Internal (<code>kube-proxy</code>) Internal (<code>kube-proxy</code>) External (cloud provider's LB) Application-layer (L7) (Ingress controller) Cost Free Free Varies by cloud provider (often charged) Requires Ingress Controller (potentially charged for underlying LB) Complexity Low Low Moderate (requires cloud provider setup) Moderate to High (requires Ingress Controller setup) Use Cases Internal microservices, backend services Demo/testing, non-production apps, exposing a few services Production apps in cloud, public APIs Production web apps (HTTP/HTTPS), multiple services on single IP, SSL termination DNS Internal DNS name Internal DNS name + NodeIP/NodePort External IP + Internal DNS name External DNS name (for Ingress Host)"},{"location":"k8s/k8s/#9-kubernetes-ingress","title":"9. Kubernetes Ingress","text":"<p>While Services expose applications, Ingress is designed for managing external access to services in a cluster, typically HTTP and HTTPS.</p>"},{"location":"k8s/k8s/#ingress-controller-and-ingress-resource","title":"Ingress Controller and Ingress Resource","text":""},{"location":"k8s/k8s/#ingress-controller","title":"Ingress Controller:","text":"<ul> <li>Definition: An application that runs in your cluster and watches the Kubernetes API for Ingress resources.</li> <li>Purpose: Fulfills the Ingress rules by acting as a reverse proxy/load balancer. Common Ingress Controllers include Nginx Ingress Controller, Traefik, Istio, GKE Ingress, AWS ALB Ingress Controller.</li> <li>Deployment: The Ingress Controller itself is typically deployed as a Deployment and exposed via a NodePort or LoadBalancer Service.</li> </ul>"},{"location":"k8s/k8s/#ingress-resource","title":"Ingress Resource:","text":"<ul> <li>Definition: A Kubernetes API object that defines rules for routing external HTTP/HTTPS traffic to Services within the cluster.</li> <li>Purpose: Provides flexible routing based on hostname, path, and TLS termination.</li> </ul> <p>Analogy: The Ingress Controller is the actual traffic cop, and the Ingress Resource is the rulebook that tells the traffic cop how to direct traffic.</p> <p>Ingress Architecture: </p>"},{"location":"k8s/k8s/#basic-ingress-yaml-example","title":"Basic Ingress YAML Example","text":"<p>This example routes traffic for <code>myapp.example.com/api</code> to <code>api-service</code> and <code>myapp.example.com/</code> to <code>frontend-service</code>.</p> <pre><code>#### my-ingress.yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-app-ingress\n  annotations:\n    # Example annotation for Nginx Ingress Controller:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: myapp.example.com\n    http:\n      paths:\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service # Name of your API Service\n            port:\n              number: 8080\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-service # Name of your Frontend Service\n            port:\n              number: 80\n  # Optional: TLS/SSL termination\n  # tls:\n  #   - hosts:\n  #       - myapp.example.com\n  #     secretName: my-app-tls-secret # Secret containing TLS certificate and key\n</code></pre> <p>Note: You must have an Ingress Controller running in your cluster for Ingress resources to work.</p>"},{"location":"k8s/k8s/#10-helm-basics","title":"10. Helm Basics","text":"<p>Helm is a package manager for Kubernetes. It simplifies the deployment and management of applications on Kubernetes clusters.</p>"},{"location":"k8s/k8s/#what-is-helm","title":"What is Helm?","text":"<ul> <li>Definition: The \"apt/yum/brew\" for Kubernetes.</li> <li>Purpose: Helps you define, install, and upgrade even the most complex Kubernetes applications.</li> </ul>"},{"location":"k8s/k8s/#key-concepts","title":"Key Concepts:","text":"<ul> <li>Charts: Pre-configured Kubernetes resource packages.</li> <li>Repositories: Places where charts are stored and shared.</li> <li>Releases: An instance of a chart running in a Kubernetes cluster.</li> </ul>"},{"location":"k8s/k8s/#helm-charts-and-their-structure","title":"Helm Charts and their Structure","text":"<p>A Helm Chart is a collection of files that describe a related set of Kubernetes resources. Think of it as a template for a Kubernetes application.</p> <p>Typical Chart Structure:</p>"},{"location":"k8s/k8s/#helm-chart-structure-my-app-chart","title":"Helm Chart Structure: <code>my-app-chart/</code>","text":"<pre><code>my-app-chart/\n\u251c\u2500\u2500 Chart.yaml          # A YAML file containing information about the chart (name, version, etc.)\n\u251c\u2500\u2500 values.yaml         # Default configuration values for the chart\n\u251c\u2500\u2500 templates/          # Directory containing Kubernetes manifest templates\n\u2502   \u251c\u2500\u2500 deployment.yaml # Template for a Deployment object\n\u2502   \u251c\u2500\u2500 service.yaml    # Template for a Service object\n\u2502   \u251c\u2500\u2500 _helpers.tpl    # Optional: Contains reusable template snippets\n\u2502   \u2514\u2500\u2500 NOTES.txt       # Optional: Instructions for the user after installation\n\u251c\u2500\u2500 charts/             # Optional: Contains dependent charts (subcharts)\n\u2514\u2500\u2500 README.md           # Optional: A brief description of the chart\n</code></pre> <p>Installing and Using Helm Commands Install Helm CLI:</p> <p>macOS (Homebrew): brew install helm</p> <p>Linux: Download from helm.sh or use package manager.</p> <p>Add a Chart Repository (e.g., Bitnami stable charts):</p> <pre><code>\nhelm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update # Update information about charts from all repositories\n</code></pre> <p>Search for Charts:</p> <pre><code>helm search repo nginx\n</code></pre> <p>Install a Chart:</p> <pre><code>\nhelm install &lt;release-name&gt; &lt;chart-name&gt; --namespace &lt;namespace&gt; --values &lt;your-values.yaml&gt;\n# Example: Install Nginx Ingress Controller\nhelm install my-nginx-ingress bitnami/nginx-ingress-controller --namespace ingress-nginx\n# Example: Install WordPress\nhelm install my-wordpress bitnami/wordpress --set mysql.rootPassword=mysecretpassword --namespace blog\n--set: Override specific values from values.yaml directly on the command line.\n\n--values: Provide an entire custom values.yaml file.\n</code></pre> <p>List Releases:</p> <pre><code>\nhelm list\nhelm list -n &lt;namespace&gt;\n</code></pre> <p>Upgrade a Release:</p> <pre><code>\nhelm upgrade &lt;release-name&gt; &lt;chart-name&gt; --namespace &lt;namespace&gt; --values &lt;your-new-values.yaml&gt;\n# Example:\nhelm upgrade my-wordpress bitnami/wordpress -f my-new-wordpress-values.yaml\n</code></pre> <p>Uninstall a Release:</p> <pre><code>\nhelm uninstall &lt;release-name&gt; --namespace &lt;namespace&gt;\n# Example:\nhelm uninstall my-wordpress -n blog\n</code></pre> <p>Get Release Status:</p> <pre><code>helm status &lt;release-name&gt; -n &lt;namespace&gt;\n</code></pre> <p>Lint a Chart (check for best practices and syntax errors):</p> <pre><code>helm lint ./my-app-chart\n</code></pre> <p>Package a Chart:</p> <pre><code>helm package ./my-app-chart\n</code></pre>"},{"location":"k8s/k8s/#11-kubernetes-security-basics","title":"11. Kubernetes Security Basics","text":"<p>Security is paramount in Kubernetes. Here are fundamental concepts.</p> <p>Role-Based Access Control (RBAC) Purpose: Authorizes users and applications to interact with the Kubernetes API.</p> <p>Concepts:</p> <ul> <li> <p>Role: Defines a set of permissions within a specific Namespace (e.g., \"can read Pods\" or \"can manage Deployments\").</p> </li> <li> <p>ClusterRole: Similar to a Role, but applies across the entire cluster (non-namespaced resources like Nodes or PersistentVolumes, or namespaced resources across all Namespaces).</p> </li> <li> <p>RoleBinding: Grants the permissions defined in a Role to a user, group, or ServiceAccount within a specific Namespace.</p> </li> <li> <p>ClusterRoleBinding: Grants the permissions defined in a ClusterRole to a user, group, or ServiceAccount across the entire cluster.</p> </li> </ul> <p>Analogy: RBAC is like defining roles in an organization (e.g., \"Manager,\" \"Developer\") and then assigning those roles to specific people or teams.</p> <p>ServiceAccount Definition: Provides an identity for processes that run in a Pod.</p> <p>Purpose: Allows Pods to authenticate to the Kubernetes API server when they need to perform actions (e.g., a controller that watches for new resources).</p> <p>Default: Every Pod automatically gets a default ServiceAccount in its Namespace, which usually has limited permissions.</p> <p>Best Practice: Create specific ServiceAccounts with the minimal necessary permissions for your applications.</p> <p>Network Policies Purpose: (As discussed in Section 6) Control Pod-to-Pod communication using firewall rules. By default, Pods are open. Network Policies allow you to isolate them.</p> <p>Best Practice: Implement Network Policies to restrict traffic flows to only what is necessary, following the principle of least privilege.</p> <p>Secrets and ConfigMaps (Best Practices) Secrets: (As discussed in Section 3) For sensitive data.</p> <p>Best Practice: Always use Secrets for credentials. Do not store sensitive data in ConfigMaps or directly in YAML files in version control.</p> <p>For production, consider external Secret management solutions (e.g., HashiCorp Vault, cloud provider KMS integrations) to avoid storing plaintext secrets in etcd or in your Kubernetes manifests.</p> <p>ConfigMaps: For non-confidential configuration.</p> <p>Best Practice: Use ConfigMaps to decouple configuration from your application images.</p>"},{"location":"k8s/k8s/#12-monitoring-and-logging","title":"12. Monitoring and Logging","text":"<p>Effective monitoring and logging are crucial for understanding the health and performance of your Kubernetes applications and cluster.</p> <p>Basic Health Checks - Liveness Probes: (See Section 14) Determine if a container is running and healthy. If a Liveness Probe fails, Kubernetes restarts the container.</p> <ul> <li>Readiness Probes: (See Section 14) Determine if a container is ready to serve traffic. If a Readiness Probe fails, the Pod is removed from Service load balancing until it becomes ready.</li> </ul> <p>kubectl logs and kubectl top - kubectl logs: (As discussed in Section 5) Retrieve standard output and standard error from containers. Essential for debugging application issues.</p> <ul> <li>kubectl top: (As discussed in Section 5) Provides basic CPU and memory usage of nodes and pods. Requires the Kubernetes Metrics Server to be installed in the cluster.</li> </ul> <p>Prometheus and Grafana Overview These are de-facto standards for monitoring in Kubernetes environments.</p> <p>Prometheus:</p> <ul> <li> <p>Purpose: A powerful open-source monitoring and alerting toolkit designed for reliability and scalability.</p> </li> <li> <p>How it works: Scrapes metrics from configured targets (Kubernetes components, application endpoints) at regular intervals, stores them, and allows for querying and alerting.</p> </li> </ul> <p>Grafana:</p> <ul> <li> <p>Purpose: An open-source analytics and interactive visualization web application.</p> </li> <li> <p>How it works: Used to create dashboards that visualize data collected by Prometheus (or other data sources). Provides powerful querying and visualization capabilities.</p> </li> </ul> <p>Typical Setup:</p> <ul> <li> <p>Prometheus Server (runs in Kubernetes) scrapes metrics.</p> </li> <li> <p>Grafana (runs in Kubernetes) connects to Prometheus as a data source and displays dashboards.</p> </li> <li> <p>Node Exporter (DaemonSet) on each node exposes node-level metrics for Prometheus.</p> </li> <li> <p>kube-state-metrics (Deployment) exposes Kubernetes object metrics (e.g., Pod status, Deployment replicas).</p> </li> </ul>"},{"location":"k8s/k8s/#13-deploying-a-full-stack-app-spring-boot-angular-mysql","title":"13. Deploying a Full-Stack App (Spring Boot + Angular + MySQL)","text":""},{"location":"k8s/k8s/#full-stack-application-architecture","title":"Full-Stack Application Architecture","text":""},{"location":"k8s/k8s/#application-components","title":"Application Components","text":"<ul> <li>Frontend: Angular application served by Nginx</li> <li>Backend: Spring Boot REST API</li> <li>Database: MySQL</li> </ul>"},{"location":"k8s/k8s/#kubernetes-application-architecture","title":"Kubernetes Application Architecture","text":"<pre><code>        User\n         |\n         V\n+---------------------+\n|  Internet / Browser |\n+---------------------+\n         | (HTTP/HTTPS)\n         V\n+---------------------+\n| Ingress Controller  |\n+---------------------+\n         |\n         |--&gt; Host: `myapp.com/api` \u2192 Spring Boot Service\n         |--&gt; Host: `myapp.com/`   \u2192 Angular Service\n         V\n+-----------------------------------+\n|     Kubernetes Cluster            |\n|                                   |\n|  +---------------------------+   |\n|  |   Frontend Service        |   |\n|  | (ClusterIP)               |   |\n|  +----+----------------------+   |\n|       |                          |\n|       V                          |\n|  +---------------------------+   |\n|  |   Frontend Deployment     |   |\n|  |   (Nginx + Angular)       |   |\n|  +---------------------------+   |\n|                                   |\n|  +---------------------------+   |\n|  |   Backend Service         |   |\n|  | (ClusterIP)               |   |\n|  +----+----------------------+   |\n|       |                          |\n|       V                          |\n|  +---------------------------+   |\n|  |   Backend Deployment      |   |\n|  |   (Spring Boot)           |   |\n|  +----+----------------------+   |\n|       |                          |\n|       V                          |\n|  +---------------------------+   |\n|  |   MySQL Service           |   |\n|  | (ClusterIP)               |   |\n|  +----+----------------------+   |\n|       |                          |\n|       V                          |\n|  +---------------------------+   |\n|  |   MySQL StatefulSet       |   |\n|  |   + PVC for Data          |   |\n|  +---------------------------+   |\n+-----------------------------------+\n</code></pre> <p>YAML Manifests:</p> <p>We'll use a single k8s-fullstack.yaml file for simplicity.</p>"},{"location":"k8s/k8s/#k8s-fullstackyaml","title":"k8s-fullstack.yaml","text":""},{"location":"k8s/k8s/#1-mysql-deployment-using-statefulset-for-persistence","title":"1. MySQL Deployment (using StatefulSet for persistence)","text":"<pre><code>apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: mysql\n  labels:\n    app: mysql\nspec:\n  selector:\n    matchLabels:\n      app: mysql\n  serviceName: \"mysql\" # headless service for stable network identity\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: mysql\n    spec:\n      containers:\n      - name: mysql\n        image: mysql:8.0\n        env:\n        - name: MYSQL_ROOT_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: mysql-secret\n              key: mysql-root-password\n        - name: MYSQL_DATABASE\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: MYSQL_DATABASE\n        ports:\n        - containerPort: 3306\n          name: mysql\n        volumeMounts:\n        - name: mysql-data # Mount the volume for persistent data\n          mountPath: /var/lib/mysql\n  volumeClaimTemplates: # Define the PVC for this StatefulSet\n  - metadata:\n      name: mysql-data\n    spec:\n      accessModes: [ \"ReadWriteOnce\" ]\n      resources:\n        requests:\n          storage: 5Gi # Request 5GB of storage\n      # storageClassName: standard # Uncomment if you have a specific StorageClass\n</code></pre>"},{"location":"k8s/k8s/#2-mysql-service-clusterip-for-internal-communication","title":"2. MySQL Service (ClusterIP, for internal communication)","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: mysql-service\n  labels:\n    app: mysql\nspec:\n  ports:\n  - port: 3306\n    targetPort: 3306\n    protocol: TCP\n    name: mysql\n  selector:\n    app: mysql\n  clusterIP: None # Headless service for StatefulSet\n</code></pre>"},{"location":"k8s/k8s/#3-spring-boot-backend-deployment","title":"3. Spring Boot Backend Deployment","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: spring-boot-backend\n  labels:\n    app: backend\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: backend\n  template:\n    metadata:\n      labels:\n        app: backend\n    spec:\n      containers:\n      - name: spring-boot-app\n        image: yourusername/spring-boot-app:1.0.0 # Replace with your image!\n        env:\n        - name: SPRING_DATASOURCE_URL\n          valueFrom:\n            configMapKeyRef:\n              name: app-config\n              key: SPRING_DATASOURCE_URL\n        - name: SPRING_DATASOURCE_USERNAME\n          valueFrom:\n            secretKeyRef:\n              name: mysql-secret\n              key: mysql-username\n        - name: SPRING_DATASOURCE_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: mysql-secret\n              key: mysql-password\n        ports:\n        - containerPort: 8080\n        livenessProbe: # Example liveness probe\n          httpGet:\n            path: /actuator/health/liveness # Adjust path for your Spring Boot app\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe: # Example readiness probe\n          httpGet:\n            path: /actuator/health/readiness # Adjust path\n            port: 8080\n          initialDelaySeconds: 15\n          periodSeconds: 5\n\n</code></pre>"},{"location":"k8s/k8s/#4-spring-boot-backend-service-clusterip-for-internal-and-ingress-access","title":"4. Spring Boot Backend Service (ClusterIP, for internal and Ingress access)","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: backend-service\n  labels:\n    app: backend\nspec:\n  selector:\n    app: backend\n  ports:\n  - protocol: TCP\n    port: 8080\n    targetPort: 8080\n  type: ClusterIP\n</code></pre>"},{"location":"k8s/k8s/#5-angular-frontend-deployment","title":"5. Angular Frontend Deployment","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: angular-frontend\n  labels:\n    app: frontend\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: frontend\n  template:\n    metadata:\n      labels:\n        app: frontend\n    spec:\n      containers:\n      - name: nginx-angular\n        image: yourusername/angular-nginx:1.0.0 # Replace with your image!\n        ports:\n        - containerPort: 80\n</code></pre>"},{"location":"k8s/k8s/#6-angular-frontend-service-clusterip-for-ingress-access","title":"6. Angular Frontend Service (ClusterIP, for Ingress access)","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: frontend-service\n  labels:\n    app: frontend\nspec:\n  selector:\n    app: frontend\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 80\n  type: ClusterIP\n</code></pre>"},{"location":"k8s/k8s/#7-configmap-for-application-configuration","title":"7. ConfigMap for application configuration","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  MYSQL_DATABASE: myappdb\n  SPRING_DATASOURCE_URL: jdbc:mysql://mysql-service:3306/myappdb?useSSL=false&amp;allowPublicKeyRetrieval=true\n</code></pre>"},{"location":"k8s/k8s/#8-secret-for-sensitive-data-base64-encoded","title":"8. Secret for sensitive data (base64 encoded)","text":"<pre><code># Create secrets first:\n# echo -n 'root_password_here' | base64\n# echo -n 'myuser' | base64\n# echo -n 'mypassword' | base64\napiVersion: v1\nkind: Secret\nmetadata:\n  name: mysql-secret\ntype: Opaque\ndata:\n  mysql-root-password: &lt;base64_encoded_root_password&gt; # e.g., cG9zdGdyZXNfcGFzc3dvcmRfaGVyZQ==\n  mysql-username: &lt;base64_encoded_db_username&gt;\n  mysql-password: &lt;base64_encoded_db_password&gt;\n</code></pre>"},{"location":"k8s/k8s/#9-ingress-for-external-routing","title":"9. Ingress for external routing","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-app-ingress\n  annotations:\n    # Use appropriate annotations for your Ingress Controller (e.g., Nginx, AWS ALB)\n    # For Nginx Ingress Controller:\n    nginx.ingress.kubernetes.io/rewrite-target: /$2 # For path stripping if needed\n    nginx.ingress.kubernetes.io/ssl-redirect: \"false\" # Optional, if not using HTTPS\nspec:\n  ingressClassName: nginx # Required for Kubernetes v1.18+\n  rules:\n  - host: myapp.example.com # Replace with your domain\n    http:\n      paths:\n      - path: /api(/|$)(.*) # Route traffic for /api to backend\n        pathType: Prefix\n        backend:\n          service:\n            name: backend-service\n            port:\n              number: 8080\n      - path: /(.*) # Route all other traffic to frontend\n        pathType: Prefix\n        backend:\n          service:\n            name: frontend-service\n            port:\n              number: 80\n  # Uncomment and configure TLS if you have a certificate secret\n  # tls:\n  #   - hosts:\n  #       - myapp.example.com\n  #     secretName: myapp-tls-secret # Create this secret with 'kubectl create secret tls myapp-tls-secret --key private.key --cert certificate.crt'\n</code></pre> <p>Deployment Steps: Build and push your Docker images:</p> <pre><code>docker build -t yourusername/spring-boot-app:1.0.0 ./spring-boot-app\ndocker push yourusername/spring-boot-app:1.0.0\ndocker build -t yourusername/angular-nginx:1.0.0 ./angular-nginx\ndocker push yourusername/angular-nginx:1.0.0\n</code></pre> <p>Create your mysql-secret:</p> <pre><code>kubectl create secret generic mysql-secret \\\n  --from-literal=mysql-root-password='your_root_password' \\\n  --from-literal=mysql-username='myuser' \\\n  --from-literal=mysql-password='mypassword'\n</code></pre> <p>Apply the full-stack YAML:</p> <pre><code>\nkubectl apply -f k8s-fullstack.yaml\n</code></pre> <p>Verify Deployments and Services:</p> <pre><code>kubectl get deployments\nkubectl get pods\nkubectl get services\nkubectl get pvc\nkubectl get ingress\n</code></pre> <p>Access the application:</p> <p>If using a cloud provider, the LoadBalancer for your Ingress Controller will get an external IP. Update your DNS A record for myapp.example.com to point to the Ingress LoadBalancer IP. Alternatively, if using NodePort for Ingress Controller, access via NodeIP:NodePort.</p>"},{"location":"k8s/k8s/#14-kubernetes-best-practices","title":"14. Kubernetes Best Practices","text":"<p>Adopting these practices ensures robust, scalable, and maintainable applications in Kubernetes.</p> <p>Liveness and Readiness Probes Liveness Probe:</p> <p>Purpose: Tells Kubernetes when to restart a container. If the Liveness Probe fails, Kubernetes knows the container is unhealthy and will terminate and restart it.</p> <p>Configuration: httpGet, tcpSocket, or exec command.</p> <p>Example (in Pod/Deployment spec):</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /healthz\n    port: 8080\n  initialDelaySeconds: 15 # Wait 15s before first check\n  periodSeconds: 10     # Check every 10s\n  timeoutSeconds: 5     # Timeout after 5s\n  failureThreshold: 3   # Restart after 3 failed attempts\nReadiness Probe:\n</code></pre> <p>Purpose: Tells Kubernetes when a container is ready to serve traffic. If the Readiness Probe fails, the Pod is removed from the Service's endpoints (no traffic is sent to it) until it becomes ready.</p> <ul> <li>Configuration: httpGet, tcpSocket, or exec command.</li> </ul> <p>Example (in Pod/Deployment spec):</p> <pre><code>readinessProbe:\n  httpGet:\n    path: /ready\n    port: 8080\n  initialDelaySeconds: 5\n  periodSeconds: 5\n  timeoutSeconds: 3\n  failureThreshold: 1 # Unready after 1 failed attempt\n</code></pre> <p>Difference: Liveness deals with \"should I restart this container?\", Readiness deals with \"is this container ready to accept requests?\".</p> <p>Resource Limits and Requests Purpose: Crucial for efficient resource allocation and cluster stability.</p> <p>requests: The minimum amount of CPU and memory a container needs. Kubernetes uses this for scheduling decisions (ensures a node has enough resources available).</p> <p>limits: The maximum amount of CPU and memory a container can use. If a container exceeds its memory limit, it's terminated. If it exceeds its CPU limit, it's throttled.</p> <p>Example (in container spec):</p> <pre><code>resources:\n  requests:\n    memory: \"256Mi\"\n    cpu: \"500m\" # 0.5 CPU core\n  limits:\n    memory: \"512Mi\"\n    cpu: \"1000m\" # 1 CPU core\n</code></pre> <p>Best Practice: Always define requests and limits for your production workloads. Separation by Namespaces Purpose: (As discussed in Section 3) Logical isolation within a cluster. Best Practice: Create separate Namespaces for different environments (e.g., dev, staging, prod). Create separate Namespaces for different teams or applications. Facilitates RBAC, Network Policies, and resource quotas. Auto-scaling with Horizontal Pod Autoscaler (HPA) Purpose: Automatically scales the number of Pod replicas in a Deployment or ReplicaSet based on observed CPU utilization or other custom metrics.</p> <p>How it works: HPA continuously monitors metrics and adjusts the replicas field of the target resource.</p> <p>Example:</p> <pre><code>\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: my-web-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: my-web-deployment # Target Deployment to scale\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70 # Target 70% average CPU utilization\n  # - type: Resource # Example for memory\n  #   resource:\n  #     name: memory\n  #     target:\n  #       type: AverageValue\n  #       averageValue: 200Mi\n  ```\n\nBest Practice: Use HPA to ensure your application can handle varying loads efficiently. Requires the Metrics Server.\n\n## 15. Cleanup and Maintenance\nRegular cleanup and maintenance are essential for keeping your Kubernetes cluster healthy and cost-efficient.\n\nCommands to Delete Resources\nDelete by file:\n\n```Bash\nkubectl delete -f &lt;filename.yaml&gt;\n</code></pre> <p>Delete by type and name:</p> <pre><code>kubectl delete deployment &lt;deployment-name&gt;\nkubectl delete service &lt;service-name&gt;\nkubectl delete pod &lt;pod-name&gt; --grace-period=0 --force # Force delete a stuck pod\nkubectl delete pvc &lt;pvc-name&gt;\nkubectl delete pv &lt;pv-name&gt; # Careful! Ensure no PVCs are using it.\n</code></pre> <p>Delete multiple resources by label:</p> <pre><code>\nkubectl delete pods -l app=nginx\n</code></pre> <p>Delete all resources of a type in a namespace:</p> <pre><code>kubectl delete all --all -n &lt;namespace&gt; # Deletes all common resources (deployments, services, pods, etc.)\n</code></pre> <p>Delete a Namespace and all its contents:</p> <pre><code>kubectl delete namespace &lt;namespace-name&gt;\n</code></pre> <p>Cleaning Up Cluster Resources Pruning unused resources (Disk space):</p> <pre><code>docker system prune -a # On your node if Docker is container runtime, to clean up unused images/containers\n</code></pre> <p>Note: This is usually done at the Docker daemon level on individual nodes, not directly kubectl. Kubernetes itself manages the lifecycle of its objects.</p> <p>Deleting PersistentVolumes: When you delete a PVC, the corresponding PV might not be automatically deleted. Check the Reclaim Policy of the PV (e.g., Retain, Recycle, Delete).</p> <p>If Retain, you must manually delete the PV after the PVC is gone.</p> <pre><code>kubectl get pv\nkubectl delete pv &lt;pv-name&gt;\nInspecting Pods\n</code></pre> <p>Check Pod status:</p> <pre><code>kubectl get pods\n</code></pre> <p>Common statuses: Running, Pending, ContainerCreating, Error, CrashLoopBackOff. Get detailed information for a specific Pod:</p> <pre><code>kubectl describe pod &lt;pod-name&gt;\n</code></pre> <p>Look at Events section for common issues (e.g., FailedScheduling, ImagePullBackOff, LivenessProbe failed).</p> <p>Check Pod logs:</p> <pre><code>\nkubectl logs &lt;pod-name&gt;\n</code></pre>"},{"location":"k8s/k8s/#16-comparison-tables","title":"16. Comparison Tables","text":""},{"location":"k8s/k8s/#docker-compose-vs-kubernetes","title":"Docker Compose vs Kubernetes","text":"Feature Docker Compose Kubernetes Primary Use Local development, single-host multi-container apps Production deployments, large-scale distributed systems Orchestration Basic (starts/stops linked containers) Advanced (auto-scaling, self-healing, rolling updates) Scalability Manual scaling on a single host (<code>docker-compose up --scale</code>) Automatic scaling across a cluster High Availability Limited to single host, no automatic failover Built-in HA, automatic failover of workloads Complexity Simpler, faster to set up for small projects Higher learning curve, more powerful and flexible Deployment Unit Service (defined in <code>docker-compose.yml</code>) Pod (managed by Deployments, StatefulSets, etc.) Networking Bridge networks between services on single host Complex networking across multiple nodes, CNI plugins Storage Docker volumes, bind mounts PV/PVC, StorageClasses, various volume types Security Basic (user/group permissions, Docker security) Robust RBAC, Network Policies, Secrets management Tools <code>docker compose</code> CLI <code>kubectl</code> CLI, Helm, dashboard, cloud provider tools Ideal For Quick local dev, small projects, PoCs Microservices, enterprise-grade applications, cloud-native"},{"location":"k8s/k8s/#replicaset-vs-deployment-vs-statefulset","title":"ReplicaSet vs Deployment vs StatefulSet","text":"Feature ReplicaSet Deployment StatefulSet Primary Purpose Ensure desired number of Pod replicas Declarative updates and management of Pods/ReplicaSets Manage stateful applications with stable identity Pod Identity No stable identity (random Pod names) No stable identity (random Pod names) Stable, unique network identifiers (e.g., <code>mysql-0</code>) Pod Ordering No guaranteed ordering for creation/deletion No guaranteed ordering for creation/deletion Guaranteed ordered, graceful deployment/deletion Persistent Storage Can use PVCs, but Pod-to-PVC mapping is not stable Can use PVCs, but Pod-to-PVC mapping is not stable Each Pod gets its own dedicated, stable PVC (via <code>volumeClaimTemplates</code>) Use Case Underlying controller for Deployments Stateless applications, web servers, APIs Databases, message queues (Kafka), distributed systems Updates Managed by Deployment for rolling updates Built-in rolling updates, rollbacks Ordered, graceful rolling updates and scaling Scale Down Behavior Arbitrary Pods are removed Arbitrary Pods are removed Pods are terminated in reverse ordinal order <p>Export to Sheets</p>"},{"location":"k8s/k8s/#17-cli-commands-grouped-by-function","title":"17. CLI Commands Grouped by Function","text":"<p>This section consolidates kubectl commands for quick reference.</p>"},{"location":"k8s/k8s/#general-cluster-information","title":"General Cluster Information","text":"<ul> <li> <p><code>kubectl version</code>   Display Kubernetes client and server versions.</p> </li> <li> <p><code>kubectl cluster-info</code>   Display information about the cluster master and services.</p> </li> <li> <p><code>kubectl config view</code>   Display merged kubeconfig settings.</p> </li> <li> <p><code>kubectl get nodes</code>   List cluster nodes.</p> </li> <li> <p><code>kubectl describe node &lt;node-name&gt;</code>   Show detailed information about a node.</p> </li> <li> <p><code>kubectl top nodes</code>   Show CPU/memory usage for nodes (requires Metrics Server).</p> </li> </ul>"},{"location":"k8s/k8s/#resource-management-crud-operations","title":"Resource Management (CRUD operations)","text":""},{"location":"k8s/k8s/#create","title":"Create","text":"<ul> <li> <p><code>kubectl apply -f &lt;filename.yaml&gt;</code>   Create or update resources defined in a YAML file. (Preferred for declarative management)</p> </li> <li> <p><code>kubectl create -f &lt;filename.yaml&gt;</code>   Create resources if they don't exist.</p> </li> <li> <p><code>kubectl create deployment &lt;name&gt; --image=&lt;image&gt;</code>   Imperatively create a Deployment.</p> </li> <li> <p><code>kubectl create service &lt;type&gt; &lt;name&gt; --tcp=&lt;port&gt;:&lt;target-port&gt;</code>   Imperatively create a Service.</p> </li> <li> <p><code>kubectl create namespace &lt;name&gt;</code>   Create a Namespace.</p> </li> <li> <p><code>kubectl create configmap &lt;name&gt; --from-literal=&lt;key&gt;=&lt;value&gt;</code>   Create a ConfigMap from literals.</p> </li> <li> <p><code>kubectl create secret generic &lt;name&gt; --from-literal=&lt;key&gt;=&lt;value&gt;</code>   Create a Secret from literals.</p> </li> <li> <p><code>kubectl create secret tls &lt;name&gt; --key=&lt;key-file&gt; --cert=&lt;cert-file&gt;</code>   Create a TLS Secret.</p> </li> </ul>"},{"location":"k8s/k8s/#get-list","title":"Get (List)","text":"<ul> <li> <p><code>kubectl get all</code>   List common resources (pods, deployments, services, replicasets).</p> </li> <li> <p><code>kubectl get pods</code>   List Pods.</p> </li> <li> <p><code>kubectl get deployments</code>   List Deployments.</p> </li> <li> <p><code>kubectl get services</code>   List Services.</p> </li> <li> <p><code>kubectl get ingress</code>   List Ingress resources.</p> </li> <li> <p><code>kubectl get configmaps</code>   List ConfigMaps.</p> </li> <li> <p><code>kubectl get secrets</code>   List Secrets.</p> </li> <li> <p><code>kubectl get pvc</code>   List PersistentVolumeClaims.</p> </li> <li> <p><code>kubectl get pv</code>   List PersistentVolumes.</p> </li> <li> <p><code>kubectl get namespaces</code>   List Namespaces.</p> </li> <li> <p><code>kubectl get daemonsets</code>   List DaemonSets.</p> </li> <li> <p><code>kubectl get statefulsets</code>   List StatefulSets.</p> </li> <li> <p><code>kubectl get jobs</code>   List Jobs.</p> </li> <li> <p><code>kubectl get cronjobs</code>   List CronJobs.</p> </li> <li> <p><code>kubectl get &lt;resource-type&gt; -n &lt;namespace&gt;</code>   Get resources in a specific Namespace.</p> </li> <li> <p><code>kubectl get &lt;resource-type&gt; -o wide</code>   Get resources with more details.</p> </li> <li> <p><code>kubectl get &lt;resource-type&gt; -l &lt;key&gt;=&lt;value&gt;</code>   Get resources filtered by label.</p> </li> <li> <p><code>kubectl get &lt;resource-type&gt; -o yaml</code>   Get resource in YAML format (useful for inspecting current state).</p> </li> </ul>"},{"location":"k8s/k8s/#describe-detailed-information","title":"Describe (Detailed Information)","text":"<ul> <li> <p><code>kubectl describe pod &lt;pod-name&gt;</code>   Describe a Pod.</p> </li> <li> <p><code>kubectl describe deployment &lt;deployment-name&gt;</code>   Describe a Deployment.</p> </li> <li> <p><code>kubectl describe service &lt;service-name&gt;</code>   Describe a Service.</p> </li> <li> <p><code>kubectl describe configmap &lt;configmap-name&gt;</code>   Describe a ConfigMap.</p> </li> <li> <p><code>kubectl describe secret &lt;secret-name&gt;</code>   Describe a Secret.</p> </li> <li> <p><code>kubectl describe pvc &lt;pvc-name&gt;</code>   Describe a PVC.</p> </li> <li> <p><code>kubectl describe pv &lt;pv-name&gt;</code>   Describe a PV.</p> </li> <li> <p><code>kubectl describe ing &lt;ingress-name&gt;</code>   Describe an Ingress.</p> </li> </ul>"},{"location":"k8s/k8s/#delete","title":"Delete","text":"<ul> <li> <p><code>kubectl delete -f &lt;filename.yaml&gt;</code>   Delete resources defined in a YAML file.</p> </li> <li> <p><code>kubectl delete pod &lt;pod-name&gt;</code>   Delete a Pod.</p> </li> <li> <p><code>kubectl delete deployment &lt;deployment-name&gt;</code>   Delete a Deployment.</p> </li> <li> <p><code>kubectl delete service &lt;service-name&gt;</code>   Delete a Service.</p> </li> <li> <p><code>kubectl delete ingress &lt;ingress-name&gt;</code>   Delete an Ingress.</p> </li> <li> <p><code>kubectl delete namespace &lt;namespace-name&gt;</code>   Delete a Namespace (and all resources within it).</p> </li> <li> <p><code>kubectl delete all --all -n &lt;namespace&gt;</code>   Delete all common resources in a Namespace.</p> </li> <li> <p><code>kubectl delete pods -l app=my-app</code>   Delete Pods by label.</p> </li> </ul>"},{"location":"k8s/k8s/#debugging-and-troubleshooting","title":"Debugging and Troubleshooting","text":"<ul> <li> <p><code>kubectl logs &lt;pod-name&gt;</code>   Print the logs for a container in a Pod.</p> </li> <li> <p><code>kubectl logs -f &lt;pod-name&gt;</code>   Stream (follow) logs.</p> </li> <li> <p><code>kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;</code>   Get logs from a specific container in a multi-container Pod.</p> </li> <li> <p><code>kubectl exec -it &lt;pod-name&gt; -- /bin/bash</code>   Execute a shell inside a running container.</p> </li> <li> <p><code>kubectl cp &lt;source-path&gt; &lt;pod-name&gt;:&lt;destination-path&gt;</code>   Copy files into a container.</p> </li> <li> <p><code>kubectl cp &lt;pod-name&gt;:&lt;source-path&gt; &lt;destination-path&gt;</code>   Copy files out of a container.</p> </li> <li> <p><code>kubectl port-forward &lt;pod-name&gt; &lt;local-port&gt;:&lt;container-port&gt;</code>   Forward a local port to a port on a Pod.</p> </li> <li> <p><code>kubectl get events</code>   List recent events in the cluster.</p> </li> </ul>"},{"location":"k8s/k8s/#scaling-and-updates_1","title":"Scaling and Updates","text":"<ul> <li> <p><code>kubectl scale deployment &lt;deployment-name&gt; --replicas=&lt;number&gt;</code>   Scale a Deployment to a specific number of replicas.</p> </li> <li> <p><code>kubectl autoscale deployment &lt;deployment-name&gt; --min=1 --max=5 --cpu-percent=70</code>   Create an HPA (Horizontal Pod Autoscaler).</p> </li> <li> <p><code>kubectl rollout status deployment/&lt;deployment-name&gt;</code>   Check the status of a deployment rollout.</p> </li> <li> <p><code>kubectl rollout history deployment/&lt;deployment-name&gt;</code>   View rollout history.</p> </li> <li> <p><code>kubectl rollout undo deployment/&lt;deployment-name&gt;</code>   Rollback to the previous deployment version.</p> </li> <li> <p><code>kubectl set image deployment/&lt;deployment-name&gt; &lt;container-name&gt;=&lt;new-image&gt;</code>   Update container image in a deployment.</p> </li> </ul>"},{"location":"k8s/k8s/#context-and-configuration","title":"Context and Configuration","text":"<ul> <li> <p><code>kubectl config get-contexts</code>   List available contexts.</p> </li> <li> <p><code>kubectl config use-context &lt;context-name&gt;</code>   Switch to a specific context.</p> </li> <li> <p><code>kubectl config set-context --current --namespace=&lt;namespace-name&gt;</code>   Set the default Namespace for the current context.</p> </li> </ul>"},{"location":"python/python/","title":"Python Basics","text":"<p>yet to start</p>"},{"location":"setup/readme/","title":"\u2699\ufe0f Setup","text":""},{"location":"setup/readme/#host-documentation-on-github-using-mkdocs","title":"Host Documentation on GitHub using MkDocs","text":"<pre><code>python --version\nmkdocks --version \npip install mkdocs\nmkdocs new .   \npip install mkdocs-material \nmkdocs serve\nmkdocs gh-deploy  \n\n</code></pre>"}]}